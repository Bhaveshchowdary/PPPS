import {
  init_lib,
  lib_exports3 as lib_exports
} from "./chunk-LM6XJJYI.js";
import {
  __commonJS,
  __require,
  __toCommonJS
} from "./chunk-PLDDJCW6.js";

// node_modules/@spruceid/siwe-parser/dist/siwe-grammar.js
var require_siwe_grammar = __commonJS({
  "node_modules/@spruceid/siwe-parser/dist/siwe-grammar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.grammar = void 0;
    function grammar() {
      this.grammarObject = "grammarObject";
      this.rules = [];
      this.rules[0] = { name: "sign-in-with-ethereum", lower: "sign-in-with-ethereum", index: 0, isBkr: false };
      this.rules[1] = { name: "ex-title", lower: "ex-title", index: 1, isBkr: false };
      this.rules[2] = { name: "nb-title", lower: "nb-title", index: 2, isBkr: false };
      this.rules[3] = { name: "ri-title", lower: "ri-title", index: 3, isBkr: false };
      this.rules[4] = { name: "re-title", lower: "re-title", index: 4, isBkr: false };
      this.rules[5] = { name: "oscheme", lower: "oscheme", index: 5, isBkr: false };
      this.rules[6] = { name: "domain", lower: "domain", index: 6, isBkr: false };
      this.rules[7] = { name: "address", lower: "address", index: 7, isBkr: false };
      this.rules[8] = { name: "statement", lower: "statement", index: 8, isBkr: false };
      this.rules[9] = { name: "empty-statement", lower: "empty-statement", index: 9, isBkr: false };
      this.rules[10] = { name: "version", lower: "version", index: 10, isBkr: false };
      this.rules[11] = { name: "nonce", lower: "nonce", index: 11, isBkr: false };
      this.rules[12] = { name: "issued-at", lower: "issued-at", index: 12, isBkr: false };
      this.rules[13] = { name: "expiration-time", lower: "expiration-time", index: 13, isBkr: false };
      this.rules[14] = { name: "not-before", lower: "not-before", index: 14, isBkr: false };
      this.rules[15] = { name: "request-id", lower: "request-id", index: 15, isBkr: false };
      this.rules[16] = { name: "chain-id", lower: "chain-id", index: 16, isBkr: false };
      this.rules[17] = { name: "resources", lower: "resources", index: 17, isBkr: false };
      this.rules[18] = { name: "resource", lower: "resource", index: 18, isBkr: false };
      this.rules[19] = { name: "URI", lower: "uri", index: 19, isBkr: false };
      this.rules[20] = { name: "hier-part", lower: "hier-part", index: 20, isBkr: false };
      this.rules[21] = { name: "scheme", lower: "scheme", index: 21, isBkr: false };
      this.rules[22] = { name: "authority", lower: "authority", index: 22, isBkr: false };
      this.rules[23] = { name: "path-abempty", lower: "path-abempty", index: 23, isBkr: false };
      this.rules[24] = { name: "path-absolute", lower: "path-absolute", index: 24, isBkr: false };
      this.rules[25] = { name: "path-rootless", lower: "path-rootless", index: 25, isBkr: false };
      this.rules[26] = { name: "path-empty", lower: "path-empty", index: 26, isBkr: false };
      this.rules[27] = { name: "userinfo-at", lower: "userinfo-at", index: 27, isBkr: false };
      this.rules[28] = { name: "userinfo", lower: "userinfo", index: 28, isBkr: false };
      this.rules[29] = { name: "host", lower: "host", index: 29, isBkr: false };
      this.rules[30] = { name: "IP-literal", lower: "ip-literal", index: 30, isBkr: false };
      this.rules[31] = { name: "IPvFuture", lower: "ipvfuture", index: 31, isBkr: false };
      this.rules[32] = { name: "IPv6address", lower: "ipv6address", index: 32, isBkr: false };
      this.rules[33] = { name: "nodcolon", lower: "nodcolon", index: 33, isBkr: false };
      this.rules[34] = { name: "dcolon", lower: "dcolon", index: 34, isBkr: false };
      this.rules[35] = { name: "h16", lower: "h16", index: 35, isBkr: false };
      this.rules[36] = { name: "h16c", lower: "h16c", index: 36, isBkr: false };
      this.rules[37] = { name: "h16n", lower: "h16n", index: 37, isBkr: false };
      this.rules[38] = { name: "h16cn", lower: "h16cn", index: 38, isBkr: false };
      this.rules[39] = { name: "IPv4address", lower: "ipv4address", index: 39, isBkr: false };
      this.rules[40] = { name: "dec-octet", lower: "dec-octet", index: 40, isBkr: false };
      this.rules[41] = { name: "dec-digit", lower: "dec-digit", index: 41, isBkr: false };
      this.rules[42] = { name: "reg-name", lower: "reg-name", index: 42, isBkr: false };
      this.rules[43] = { name: "reg-name-char", lower: "reg-name-char", index: 43, isBkr: false };
      this.rules[44] = { name: "port", lower: "port", index: 44, isBkr: false };
      this.rules[45] = { name: "query", lower: "query", index: 45, isBkr: false };
      this.rules[46] = { name: "fragment", lower: "fragment", index: 46, isBkr: false };
      this.rules[47] = { name: "URI-r", lower: "uri-r", index: 47, isBkr: false };
      this.rules[48] = { name: "hier-part-r", lower: "hier-part-r", index: 48, isBkr: false };
      this.rules[49] = { name: "scheme-r", lower: "scheme-r", index: 49, isBkr: false };
      this.rules[50] = { name: "query-r", lower: "query-r", index: 50, isBkr: false };
      this.rules[51] = { name: "fragment-r", lower: "fragment-r", index: 51, isBkr: false };
      this.rules[52] = { name: "authority-d", lower: "authority-d", index: 52, isBkr: false };
      this.rules[53] = { name: "userinfo-d", lower: "userinfo-d", index: 53, isBkr: false };
      this.rules[54] = { name: "host-d", lower: "host-d", index: 54, isBkr: false };
      this.rules[55] = { name: "port-d", lower: "port-d", index: 55, isBkr: false };
      this.rules[56] = { name: "path-abempty-r", lower: "path-abempty-r", index: 56, isBkr: false };
      this.rules[57] = { name: "path-absolute-r", lower: "path-absolute-r", index: 57, isBkr: false };
      this.rules[58] = { name: "path-rootless-r", lower: "path-rootless-r", index: 58, isBkr: false };
      this.rules[59] = { name: "path-empty-r", lower: "path-empty-r", index: 59, isBkr: false };
      this.rules[60] = { name: "segment", lower: "segment", index: 60, isBkr: false };
      this.rules[61] = { name: "segment-nz", lower: "segment-nz", index: 61, isBkr: false };
      this.rules[62] = { name: "pchar", lower: "pchar", index: 62, isBkr: false };
      this.rules[63] = { name: "pct-encoded", lower: "pct-encoded", index: 63, isBkr: false };
      this.rules[64] = { name: "date-fullyear", lower: "date-fullyear", index: 64, isBkr: false };
      this.rules[65] = { name: "date-month", lower: "date-month", index: 65, isBkr: false };
      this.rules[66] = { name: "date-mday", lower: "date-mday", index: 66, isBkr: false };
      this.rules[67] = { name: "time-hour", lower: "time-hour", index: 67, isBkr: false };
      this.rules[68] = { name: "time-minute", lower: "time-minute", index: 68, isBkr: false };
      this.rules[69] = { name: "time-second", lower: "time-second", index: 69, isBkr: false };
      this.rules[70] = { name: "time-secfrac", lower: "time-secfrac", index: 70, isBkr: false };
      this.rules[71] = { name: "time-numoffset", lower: "time-numoffset", index: 71, isBkr: false };
      this.rules[72] = { name: "time-offset", lower: "time-offset", index: 72, isBkr: false };
      this.rules[73] = { name: "partial-time", lower: "partial-time", index: 73, isBkr: false };
      this.rules[74] = { name: "full-date", lower: "full-date", index: 74, isBkr: false };
      this.rules[75] = { name: "full-time", lower: "full-time", index: 75, isBkr: false };
      this.rules[76] = { name: "date-time", lower: "date-time", index: 76, isBkr: false };
      this.rules[77] = { name: "ALPHA", lower: "alpha", index: 77, isBkr: false };
      this.rules[78] = { name: "LF", lower: "lf", index: 78, isBkr: false };
      this.rules[79] = { name: "DIGIT", lower: "digit", index: 79, isBkr: false };
      this.rules[80] = { name: "HEXDIG", lower: "hexdig", index: 80, isBkr: false };
      this.udts = [];
      this.rules[0].opcodes = [];
      this.rules[0].opcodes[0] = { type: 2, children: [1, 2, 3, 4, 5, 6, 7, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 36, 41, 46] };
      this.rules[0].opcodes[1] = { type: 4, index: 5 };
      this.rules[0].opcodes[2] = { type: 4, index: 6 };
      this.rules[0].opcodes[3] = { type: 6, string: [32, 119, 97, 110, 116, 115, 32, 121, 111, 117, 32, 116, 111, 32, 115, 105, 103, 110, 32, 105, 110, 32, 119, 105, 116, 104, 32, 121, 111, 117, 114, 32, 69, 116, 104, 101, 114, 101, 117, 109, 32, 97, 99, 99, 111, 117, 110, 116, 58] };
      this.rules[0].opcodes[4] = { type: 4, index: 78 };
      this.rules[0].opcodes[5] = { type: 4, index: 7 };
      this.rules[0].opcodes[6] = { type: 4, index: 78 };
      this.rules[0].opcodes[7] = { type: 1, children: [8, 13, 14] };
      this.rules[0].opcodes[8] = { type: 2, children: [9, 10, 11, 12] };
      this.rules[0].opcodes[9] = { type: 4, index: 78 };
      this.rules[0].opcodes[10] = { type: 4, index: 8 };
      this.rules[0].opcodes[11] = { type: 4, index: 78 };
      this.rules[0].opcodes[12] = { type: 4, index: 78 };
      this.rules[0].opcodes[13] = { type: 4, index: 9 };
      this.rules[0].opcodes[14] = { type: 2, children: [15, 16] };
      this.rules[0].opcodes[15] = { type: 4, index: 78 };
      this.rules[0].opcodes[16] = { type: 4, index: 78 };
      this.rules[0].opcodes[17] = { type: 6, string: [85, 82, 73, 58, 32] };
      this.rules[0].opcodes[18] = { type: 4, index: 19 };
      this.rules[0].opcodes[19] = { type: 4, index: 78 };
      this.rules[0].opcodes[20] = { type: 6, string: [86, 101, 114, 115, 105, 111, 110, 58, 32] };
      this.rules[0].opcodes[21] = { type: 4, index: 10 };
      this.rules[0].opcodes[22] = { type: 4, index: 78 };
      this.rules[0].opcodes[23] = { type: 6, string: [67, 104, 97, 105, 110, 32, 73, 68, 58, 32] };
      this.rules[0].opcodes[24] = { type: 4, index: 16 };
      this.rules[0].opcodes[25] = { type: 4, index: 78 };
      this.rules[0].opcodes[26] = { type: 6, string: [78, 111, 110, 99, 101, 58, 32] };
      this.rules[0].opcodes[27] = { type: 4, index: 11 };
      this.rules[0].opcodes[28] = { type: 4, index: 78 };
      this.rules[0].opcodes[29] = { type: 6, string: [73, 115, 115, 117, 101, 100, 32, 65, 116, 58, 32] };
      this.rules[0].opcodes[30] = { type: 4, index: 12 };
      this.rules[0].opcodes[31] = { type: 3, min: 0, max: 1 };
      this.rules[0].opcodes[32] = { type: 2, children: [33, 34, 35] };
      this.rules[0].opcodes[33] = { type: 4, index: 78 };
      this.rules[0].opcodes[34] = { type: 4, index: 1 };
      this.rules[0].opcodes[35] = { type: 4, index: 13 };
      this.rules[0].opcodes[36] = { type: 3, min: 0, max: 1 };
      this.rules[0].opcodes[37] = { type: 2, children: [38, 39, 40] };
      this.rules[0].opcodes[38] = { type: 4, index: 78 };
      this.rules[0].opcodes[39] = { type: 4, index: 2 };
      this.rules[0].opcodes[40] = { type: 4, index: 14 };
      this.rules[0].opcodes[41] = { type: 3, min: 0, max: 1 };
      this.rules[0].opcodes[42] = { type: 2, children: [43, 44, 45] };
      this.rules[0].opcodes[43] = { type: 4, index: 78 };
      this.rules[0].opcodes[44] = { type: 4, index: 3 };
      this.rules[0].opcodes[45] = { type: 4, index: 15 };
      this.rules[0].opcodes[46] = { type: 3, min: 0, max: 1 };
      this.rules[0].opcodes[47] = { type: 2, children: [48, 49, 50] };
      this.rules[0].opcodes[48] = { type: 4, index: 78 };
      this.rules[0].opcodes[49] = { type: 4, index: 4 };
      this.rules[0].opcodes[50] = { type: 4, index: 17 };
      this.rules[1].opcodes = [];
      this.rules[1].opcodes[0] = { type: 6, string: [69, 120, 112, 105, 114, 97, 116, 105, 111, 110, 32, 84, 105, 109, 101, 58, 32] };
      this.rules[2].opcodes = [];
      this.rules[2].opcodes[0] = { type: 6, string: [78, 111, 116, 32, 66, 101, 102, 111, 114, 101, 58, 32] };
      this.rules[3].opcodes = [];
      this.rules[3].opcodes[0] = { type: 6, string: [82, 101, 113, 117, 101, 115, 116, 32, 73, 68, 58, 32] };
      this.rules[4].opcodes = [];
      this.rules[4].opcodes[0] = { type: 6, string: [82, 101, 115, 111, 117, 114, 99, 101, 115, 58] };
      this.rules[5].opcodes = [];
      this.rules[5].opcodes[0] = { type: 3, min: 0, max: 1 };
      this.rules[5].opcodes[1] = { type: 2, children: [2, 3, 9] };
      this.rules[5].opcodes[2] = { type: 4, index: 77 };
      this.rules[5].opcodes[3] = { type: 3, min: 0, max: Infinity };
      this.rules[5].opcodes[4] = { type: 1, children: [5, 6, 7, 8] };
      this.rules[5].opcodes[5] = { type: 4, index: 77 };
      this.rules[5].opcodes[6] = { type: 4, index: 79 };
      this.rules[5].opcodes[7] = { type: 6, string: [43] };
      this.rules[5].opcodes[8] = { type: 5, min: 45, max: 46 };
      this.rules[5].opcodes[9] = { type: 7, string: [58, 47, 47] };
      this.rules[6].opcodes = [];
      this.rules[6].opcodes[0] = { type: 4, index: 52 };
      this.rules[7].opcodes = [];
      this.rules[7].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[7].opcodes[1] = { type: 7, string: [48, 120] };
      this.rules[7].opcodes[2] = { type: 3, min: 40, max: 40 };
      this.rules[7].opcodes[3] = { type: 4, index: 80 };
      this.rules[8].opcodes = [];
      this.rules[8].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[8].opcodes[1] = { type: 1, children: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13] };
      this.rules[8].opcodes[2] = { type: 5, min: 97, max: 122 };
      this.rules[8].opcodes[3] = { type: 5, min: 65, max: 90 };
      this.rules[8].opcodes[4] = { type: 5, min: 48, max: 57 };
      this.rules[8].opcodes[5] = { type: 5, min: 32, max: 33 };
      this.rules[8].opcodes[6] = { type: 5, min: 35, max: 36 };
      this.rules[8].opcodes[7] = { type: 5, min: 38, max: 59 };
      this.rules[8].opcodes[8] = { type: 6, string: [61] };
      this.rules[8].opcodes[9] = { type: 5, min: 63, max: 64 };
      this.rules[8].opcodes[10] = { type: 6, string: [91] };
      this.rules[8].opcodes[11] = { type: 6, string: [93] };
      this.rules[8].opcodes[12] = { type: 6, string: [95] };
      this.rules[8].opcodes[13] = { type: 6, string: [126] };
      this.rules[9].opcodes = [];
      this.rules[9].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[9].opcodes[1] = { type: 4, index: 78 };
      this.rules[9].opcodes[2] = { type: 4, index: 78 };
      this.rules[9].opcodes[3] = { type: 4, index: 78 };
      this.rules[10].opcodes = [];
      this.rules[10].opcodes[0] = { type: 7, string: [49] };
      this.rules[11].opcodes = [];
      this.rules[11].opcodes[0] = { type: 3, min: 8, max: Infinity };
      this.rules[11].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[11].opcodes[2] = { type: 4, index: 77 };
      this.rules[11].opcodes[3] = { type: 4, index: 79 };
      this.rules[12].opcodes = [];
      this.rules[12].opcodes[0] = { type: 4, index: 76 };
      this.rules[13].opcodes = [];
      this.rules[13].opcodes[0] = { type: 4, index: 76 };
      this.rules[14].opcodes = [];
      this.rules[14].opcodes[0] = { type: 4, index: 76 };
      this.rules[15].opcodes = [];
      this.rules[15].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[15].opcodes[1] = { type: 4, index: 62 };
      this.rules[16].opcodes = [];
      this.rules[16].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[16].opcodes[1] = { type: 4, index: 79 };
      this.rules[17].opcodes = [];
      this.rules[17].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[17].opcodes[1] = { type: 2, children: [2, 3] };
      this.rules[17].opcodes[2] = { type: 4, index: 78 };
      this.rules[17].opcodes[3] = { type: 4, index: 18 };
      this.rules[18].opcodes = [];
      this.rules[18].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[18].opcodes[1] = { type: 7, string: [45, 32] };
      this.rules[18].opcodes[2] = { type: 4, index: 47 };
      this.rules[19].opcodes = [];
      this.rules[19].opcodes[0] = { type: 2, children: [1, 2, 3, 4, 8] };
      this.rules[19].opcodes[1] = { type: 4, index: 21 };
      this.rules[19].opcodes[2] = { type: 7, string: [58] };
      this.rules[19].opcodes[3] = { type: 4, index: 20 };
      this.rules[19].opcodes[4] = { type: 3, min: 0, max: 1 };
      this.rules[19].opcodes[5] = { type: 2, children: [6, 7] };
      this.rules[19].opcodes[6] = { type: 7, string: [63] };
      this.rules[19].opcodes[7] = { type: 4, index: 45 };
      this.rules[19].opcodes[8] = { type: 3, min: 0, max: 1 };
      this.rules[19].opcodes[9] = { type: 2, children: [10, 11] };
      this.rules[19].opcodes[10] = { type: 7, string: [35] };
      this.rules[19].opcodes[11] = { type: 4, index: 46 };
      this.rules[20].opcodes = [];
      this.rules[20].opcodes[0] = { type: 1, children: [1, 5, 6, 7] };
      this.rules[20].opcodes[1] = { type: 2, children: [2, 3, 4] };
      this.rules[20].opcodes[2] = { type: 7, string: [47, 47] };
      this.rules[20].opcodes[3] = { type: 4, index: 22 };
      this.rules[20].opcodes[4] = { type: 4, index: 23 };
      this.rules[20].opcodes[5] = { type: 4, index: 24 };
      this.rules[20].opcodes[6] = { type: 4, index: 25 };
      this.rules[20].opcodes[7] = { type: 4, index: 26 };
      this.rules[21].opcodes = [];
      this.rules[21].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[21].opcodes[1] = { type: 4, index: 77 };
      this.rules[21].opcodes[2] = { type: 3, min: 0, max: Infinity };
      this.rules[21].opcodes[3] = { type: 1, children: [4, 5, 6, 7] };
      this.rules[21].opcodes[4] = { type: 4, index: 77 };
      this.rules[21].opcodes[5] = { type: 4, index: 79 };
      this.rules[21].opcodes[6] = { type: 6, string: [43] };
      this.rules[21].opcodes[7] = { type: 5, min: 45, max: 46 };
      this.rules[22].opcodes = [];
      this.rules[22].opcodes[0] = { type: 2, children: [1, 3, 4] };
      this.rules[22].opcodes[1] = { type: 3, min: 0, max: 1 };
      this.rules[22].opcodes[2] = { type: 4, index: 27 };
      this.rules[22].opcodes[3] = { type: 4, index: 29 };
      this.rules[22].opcodes[4] = { type: 3, min: 0, max: 1 };
      this.rules[22].opcodes[5] = { type: 2, children: [6, 7] };
      this.rules[22].opcodes[6] = { type: 7, string: [58] };
      this.rules[22].opcodes[7] = { type: 4, index: 44 };
      this.rules[23].opcodes = [];
      this.rules[23].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[23].opcodes[1] = { type: 2, children: [2, 3] };
      this.rules[23].opcodes[2] = { type: 7, string: [47] };
      this.rules[23].opcodes[3] = { type: 4, index: 60 };
      this.rules[24].opcodes = [];
      this.rules[24].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[24].opcodes[1] = { type: 7, string: [47] };
      this.rules[24].opcodes[2] = { type: 3, min: 0, max: 1 };
      this.rules[24].opcodes[3] = { type: 2, children: [4, 5] };
      this.rules[24].opcodes[4] = { type: 4, index: 61 };
      this.rules[24].opcodes[5] = { type: 3, min: 0, max: Infinity };
      this.rules[24].opcodes[6] = { type: 2, children: [7, 8] };
      this.rules[24].opcodes[7] = { type: 7, string: [47] };
      this.rules[24].opcodes[8] = { type: 4, index: 60 };
      this.rules[25].opcodes = [];
      this.rules[25].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[25].opcodes[1] = { type: 4, index: 61 };
      this.rules[25].opcodes[2] = { type: 3, min: 0, max: Infinity };
      this.rules[25].opcodes[3] = { type: 2, children: [4, 5] };
      this.rules[25].opcodes[4] = { type: 7, string: [47] };
      this.rules[25].opcodes[5] = { type: 4, index: 60 };
      this.rules[26].opcodes = [];
      this.rules[26].opcodes[0] = { type: 7, string: [] };
      this.rules[27].opcodes = [];
      this.rules[27].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[27].opcodes[1] = { type: 4, index: 28 };
      this.rules[27].opcodes[2] = { type: 6, string: [64] };
      this.rules[28].opcodes = [];
      this.rules[28].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[28].opcodes[1] = { type: 1, children: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] };
      this.rules[28].opcodes[2] = { type: 5, min: 97, max: 122 };
      this.rules[28].opcodes[3] = { type: 5, min: 65, max: 90 };
      this.rules[28].opcodes[4] = { type: 5, min: 48, max: 57 };
      this.rules[28].opcodes[5] = { type: 4, index: 63 };
      this.rules[28].opcodes[6] = { type: 6, string: [33] };
      this.rules[28].opcodes[7] = { type: 6, string: [36] };
      this.rules[28].opcodes[8] = { type: 5, min: 38, max: 46 };
      this.rules[28].opcodes[9] = { type: 5, min: 58, max: 59 };
      this.rules[28].opcodes[10] = { type: 6, string: [61] };
      this.rules[28].opcodes[11] = { type: 6, string: [95] };
      this.rules[28].opcodes[12] = { type: 6, string: [126] };
      this.rules[29].opcodes = [];
      this.rules[29].opcodes[0] = { type: 1, children: [1, 2, 6] };
      this.rules[29].opcodes[1] = { type: 4, index: 30 };
      this.rules[29].opcodes[2] = { type: 2, children: [3, 4] };
      this.rules[29].opcodes[3] = { type: 4, index: 39 };
      this.rules[29].opcodes[4] = { type: 13 };
      this.rules[29].opcodes[5] = { type: 4, index: 43 };
      this.rules[29].opcodes[6] = { type: 4, index: 42 };
      this.rules[30].opcodes = [];
      this.rules[30].opcodes[0] = { type: 2, children: [1, 2, 5] };
      this.rules[30].opcodes[1] = { type: 7, string: [91] };
      this.rules[30].opcodes[2] = { type: 1, children: [3, 4] };
      this.rules[30].opcodes[3] = { type: 4, index: 32 };
      this.rules[30].opcodes[4] = { type: 4, index: 31 };
      this.rules[30].opcodes[5] = { type: 7, string: [93] };
      this.rules[31].opcodes = [];
      this.rules[31].opcodes[0] = { type: 2, children: [1, 2, 4, 5] };
      this.rules[31].opcodes[1] = { type: 7, string: [118] };
      this.rules[31].opcodes[2] = { type: 3, min: 1, max: Infinity };
      this.rules[31].opcodes[3] = { type: 4, index: 80 };
      this.rules[31].opcodes[4] = { type: 7, string: [46] };
      this.rules[31].opcodes[5] = { type: 3, min: 1, max: Infinity };
      this.rules[31].opcodes[6] = { type: 1, children: [7, 8, 9, 10, 11, 12, 13, 14, 15, 16] };
      this.rules[31].opcodes[7] = { type: 5, min: 97, max: 122 };
      this.rules[31].opcodes[8] = { type: 5, min: 65, max: 90 };
      this.rules[31].opcodes[9] = { type: 5, min: 48, max: 57 };
      this.rules[31].opcodes[10] = { type: 6, string: [33] };
      this.rules[31].opcodes[11] = { type: 6, string: [36] };
      this.rules[31].opcodes[12] = { type: 5, min: 38, max: 46 };
      this.rules[31].opcodes[13] = { type: 5, min: 58, max: 59 };
      this.rules[31].opcodes[14] = { type: 6, string: [61] };
      this.rules[31].opcodes[15] = { type: 6, string: [95] };
      this.rules[31].opcodes[16] = { type: 6, string: [126] };
      this.rules[32].opcodes = [];
      this.rules[32].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[32].opcodes[1] = { type: 4, index: 33 };
      this.rules[32].opcodes[2] = { type: 4, index: 34 };
      this.rules[33].opcodes = [];
      this.rules[33].opcodes[0] = { type: 2, children: [1, 5] };
      this.rules[33].opcodes[1] = { type: 2, children: [2, 3] };
      this.rules[33].opcodes[2] = { type: 4, index: 37 };
      this.rules[33].opcodes[3] = { type: 3, min: 0, max: Infinity };
      this.rules[33].opcodes[4] = { type: 4, index: 38 };
      this.rules[33].opcodes[5] = { type: 3, min: 0, max: 1 };
      this.rules[33].opcodes[6] = { type: 2, children: [7, 8] };
      this.rules[33].opcodes[7] = { type: 6, string: [58] };
      this.rules[33].opcodes[8] = { type: 4, index: 39 };
      this.rules[34].opcodes = [];
      this.rules[34].opcodes[0] = { type: 2, children: [1, 6, 7] };
      this.rules[34].opcodes[1] = { type: 3, min: 0, max: 1 };
      this.rules[34].opcodes[2] = { type: 2, children: [3, 4] };
      this.rules[34].opcodes[3] = { type: 4, index: 35 };
      this.rules[34].opcodes[4] = { type: 3, min: 0, max: Infinity };
      this.rules[34].opcodes[5] = { type: 4, index: 36 };
      this.rules[34].opcodes[6] = { type: 6, string: [58, 58] };
      this.rules[34].opcodes[7] = { type: 1, children: [8, 17] };
      this.rules[34].opcodes[8] = { type: 2, children: [9, 13] };
      this.rules[34].opcodes[9] = { type: 2, children: [10, 11] };
      this.rules[34].opcodes[10] = { type: 4, index: 37 };
      this.rules[34].opcodes[11] = { type: 3, min: 0, max: Infinity };
      this.rules[34].opcodes[12] = { type: 4, index: 38 };
      this.rules[34].opcodes[13] = { type: 3, min: 0, max: 1 };
      this.rules[34].opcodes[14] = { type: 2, children: [15, 16] };
      this.rules[34].opcodes[15] = { type: 6, string: [58] };
      this.rules[34].opcodes[16] = { type: 4, index: 39 };
      this.rules[34].opcodes[17] = { type: 3, min: 0, max: 1 };
      this.rules[34].opcodes[18] = { type: 4, index: 39 };
      this.rules[35].opcodes = [];
      this.rules[35].opcodes[0] = { type: 3, min: 1, max: 4 };
      this.rules[35].opcodes[1] = { type: 4, index: 80 };
      this.rules[36].opcodes = [];
      this.rules[36].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[36].opcodes[1] = { type: 6, string: [58] };
      this.rules[36].opcodes[2] = { type: 3, min: 1, max: 4 };
      this.rules[36].opcodes[3] = { type: 4, index: 80 };
      this.rules[37].opcodes = [];
      this.rules[37].opcodes[0] = { type: 2, children: [1, 3] };
      this.rules[37].opcodes[1] = { type: 3, min: 1, max: 4 };
      this.rules[37].opcodes[2] = { type: 4, index: 80 };
      this.rules[37].opcodes[3] = { type: 13 };
      this.rules[37].opcodes[4] = { type: 6, string: [46] };
      this.rules[38].opcodes = [];
      this.rules[38].opcodes[0] = { type: 2, children: [1, 2, 4] };
      this.rules[38].opcodes[1] = { type: 6, string: [58] };
      this.rules[38].opcodes[2] = { type: 3, min: 1, max: 4 };
      this.rules[38].opcodes[3] = { type: 4, index: 80 };
      this.rules[38].opcodes[4] = { type: 13 };
      this.rules[38].opcodes[5] = { type: 6, string: [46] };
      this.rules[39].opcodes = [];
      this.rules[39].opcodes[0] = { type: 2, children: [1, 2, 3, 4, 5, 6, 7] };
      this.rules[39].opcodes[1] = { type: 4, index: 40 };
      this.rules[39].opcodes[2] = { type: 7, string: [46] };
      this.rules[39].opcodes[3] = { type: 4, index: 40 };
      this.rules[39].opcodes[4] = { type: 7, string: [46] };
      this.rules[39].opcodes[5] = { type: 4, index: 40 };
      this.rules[39].opcodes[6] = { type: 7, string: [46] };
      this.rules[39].opcodes[7] = { type: 4, index: 40 };
      this.rules[40].opcodes = [];
      this.rules[40].opcodes[0] = { type: 3, min: 0, max: 3 };
      this.rules[40].opcodes[1] = { type: 4, index: 41 };
      this.rules[41].opcodes = [];
      this.rules[41].opcodes[0] = { type: 5, min: 48, max: 57 };
      this.rules[42].opcodes = [];
      this.rules[42].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[42].opcodes[1] = { type: 4, index: 43 };
      this.rules[43].opcodes = [];
      this.rules[43].opcodes[0] = { type: 1, children: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] };
      this.rules[43].opcodes[1] = { type: 5, min: 97, max: 122 };
      this.rules[43].opcodes[2] = { type: 5, min: 65, max: 90 };
      this.rules[43].opcodes[3] = { type: 5, min: 48, max: 57 };
      this.rules[43].opcodes[4] = { type: 4, index: 63 };
      this.rules[43].opcodes[5] = { type: 6, string: [33] };
      this.rules[43].opcodes[6] = { type: 6, string: [36] };
      this.rules[43].opcodes[7] = { type: 5, min: 38, max: 46 };
      this.rules[43].opcodes[8] = { type: 6, string: [59] };
      this.rules[43].opcodes[9] = { type: 6, string: [61] };
      this.rules[43].opcodes[10] = { type: 6, string: [95] };
      this.rules[43].opcodes[11] = { type: 6, string: [126] };
      this.rules[44].opcodes = [];
      this.rules[44].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[44].opcodes[1] = { type: 4, index: 79 };
      this.rules[45].opcodes = [];
      this.rules[45].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[45].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[45].opcodes[2] = { type: 4, index: 62 };
      this.rules[45].opcodes[3] = { type: 6, string: [47] };
      this.rules[45].opcodes[4] = { type: 6, string: [63] };
      this.rules[46].opcodes = [];
      this.rules[46].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[46].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[46].opcodes[2] = { type: 4, index: 62 };
      this.rules[46].opcodes[3] = { type: 6, string: [47] };
      this.rules[46].opcodes[4] = { type: 6, string: [63] };
      this.rules[47].opcodes = [];
      this.rules[47].opcodes[0] = { type: 2, children: [1, 2, 3, 4, 8] };
      this.rules[47].opcodes[1] = { type: 4, index: 49 };
      this.rules[47].opcodes[2] = { type: 7, string: [58] };
      this.rules[47].opcodes[3] = { type: 4, index: 48 };
      this.rules[47].opcodes[4] = { type: 3, min: 0, max: 1 };
      this.rules[47].opcodes[5] = { type: 2, children: [6, 7] };
      this.rules[47].opcodes[6] = { type: 7, string: [63] };
      this.rules[47].opcodes[7] = { type: 4, index: 50 };
      this.rules[47].opcodes[8] = { type: 3, min: 0, max: 1 };
      this.rules[47].opcodes[9] = { type: 2, children: [10, 11] };
      this.rules[47].opcodes[10] = { type: 7, string: [35] };
      this.rules[47].opcodes[11] = { type: 4, index: 51 };
      this.rules[48].opcodes = [];
      this.rules[48].opcodes[0] = { type: 1, children: [1, 5, 6, 7] };
      this.rules[48].opcodes[1] = { type: 2, children: [2, 3, 4] };
      this.rules[48].opcodes[2] = { type: 7, string: [47, 47] };
      this.rules[48].opcodes[3] = { type: 4, index: 52 };
      this.rules[48].opcodes[4] = { type: 4, index: 56 };
      this.rules[48].opcodes[5] = { type: 4, index: 57 };
      this.rules[48].opcodes[6] = { type: 4, index: 58 };
      this.rules[48].opcodes[7] = { type: 4, index: 59 };
      this.rules[49].opcodes = [];
      this.rules[49].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[49].opcodes[1] = { type: 4, index: 77 };
      this.rules[49].opcodes[2] = { type: 3, min: 0, max: Infinity };
      this.rules[49].opcodes[3] = { type: 1, children: [4, 5, 6, 7] };
      this.rules[49].opcodes[4] = { type: 4, index: 77 };
      this.rules[49].opcodes[5] = { type: 4, index: 79 };
      this.rules[49].opcodes[6] = { type: 6, string: [43] };
      this.rules[49].opcodes[7] = { type: 5, min: 45, max: 46 };
      this.rules[50].opcodes = [];
      this.rules[50].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[50].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[50].opcodes[2] = { type: 4, index: 62 };
      this.rules[50].opcodes[3] = { type: 6, string: [47] };
      this.rules[50].opcodes[4] = { type: 6, string: [63] };
      this.rules[51].opcodes = [];
      this.rules[51].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[51].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[51].opcodes[2] = { type: 4, index: 62 };
      this.rules[51].opcodes[3] = { type: 6, string: [47] };
      this.rules[51].opcodes[4] = { type: 6, string: [63] };
      this.rules[52].opcodes = [];
      this.rules[52].opcodes[0] = { type: 2, children: [1, 5, 6] };
      this.rules[52].opcodes[1] = { type: 3, min: 0, max: 1 };
      this.rules[52].opcodes[2] = { type: 2, children: [3, 4] };
      this.rules[52].opcodes[3] = { type: 4, index: 53 };
      this.rules[52].opcodes[4] = { type: 6, string: [64] };
      this.rules[52].opcodes[5] = { type: 4, index: 54 };
      this.rules[52].opcodes[6] = { type: 3, min: 0, max: 1 };
      this.rules[52].opcodes[7] = { type: 2, children: [8, 9] };
      this.rules[52].opcodes[8] = { type: 7, string: [58] };
      this.rules[52].opcodes[9] = { type: 4, index: 55 };
      this.rules[53].opcodes = [];
      this.rules[53].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[53].opcodes[1] = { type: 1, children: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] };
      this.rules[53].opcodes[2] = { type: 5, min: 97, max: 122 };
      this.rules[53].opcodes[3] = { type: 5, min: 65, max: 90 };
      this.rules[53].opcodes[4] = { type: 5, min: 48, max: 57 };
      this.rules[53].opcodes[5] = { type: 4, index: 63 };
      this.rules[53].opcodes[6] = { type: 6, string: [33] };
      this.rules[53].opcodes[7] = { type: 6, string: [36] };
      this.rules[53].opcodes[8] = { type: 5, min: 38, max: 46 };
      this.rules[53].opcodes[9] = { type: 5, min: 58, max: 59 };
      this.rules[53].opcodes[10] = { type: 6, string: [61] };
      this.rules[53].opcodes[11] = { type: 6, string: [95] };
      this.rules[53].opcodes[12] = { type: 6, string: [126] };
      this.rules[54].opcodes = [];
      this.rules[54].opcodes[0] = { type: 1, children: [1, 2, 6] };
      this.rules[54].opcodes[1] = { type: 4, index: 30 };
      this.rules[54].opcodes[2] = { type: 2, children: [3, 4] };
      this.rules[54].opcodes[3] = { type: 4, index: 39 };
      this.rules[54].opcodes[4] = { type: 13 };
      this.rules[54].opcodes[5] = { type: 4, index: 43 };
      this.rules[54].opcodes[6] = { type: 4, index: 42 };
      this.rules[55].opcodes = [];
      this.rules[55].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[55].opcodes[1] = { type: 4, index: 79 };
      this.rules[56].opcodes = [];
      this.rules[56].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[56].opcodes[1] = { type: 2, children: [2, 3] };
      this.rules[56].opcodes[2] = { type: 7, string: [47] };
      this.rules[56].opcodes[3] = { type: 4, index: 60 };
      this.rules[57].opcodes = [];
      this.rules[57].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[57].opcodes[1] = { type: 7, string: [47] };
      this.rules[57].opcodes[2] = { type: 3, min: 0, max: 1 };
      this.rules[57].opcodes[3] = { type: 2, children: [4, 5] };
      this.rules[57].opcodes[4] = { type: 4, index: 61 };
      this.rules[57].opcodes[5] = { type: 3, min: 0, max: Infinity };
      this.rules[57].opcodes[6] = { type: 2, children: [7, 8] };
      this.rules[57].opcodes[7] = { type: 7, string: [47] };
      this.rules[57].opcodes[8] = { type: 4, index: 60 };
      this.rules[58].opcodes = [];
      this.rules[58].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[58].opcodes[1] = { type: 4, index: 61 };
      this.rules[58].opcodes[2] = { type: 3, min: 0, max: Infinity };
      this.rules[58].opcodes[3] = { type: 2, children: [4, 5] };
      this.rules[58].opcodes[4] = { type: 7, string: [47] };
      this.rules[58].opcodes[5] = { type: 4, index: 60 };
      this.rules[59].opcodes = [];
      this.rules[59].opcodes[0] = { type: 7, string: [] };
      this.rules[60].opcodes = [];
      this.rules[60].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[60].opcodes[1] = { type: 4, index: 62 };
      this.rules[61].opcodes = [];
      this.rules[61].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[61].opcodes[1] = { type: 4, index: 62 };
      this.rules[62].opcodes = [];
      this.rules[62].opcodes[0] = { type: 1, children: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] };
      this.rules[62].opcodes[1] = { type: 5, min: 97, max: 122 };
      this.rules[62].opcodes[2] = { type: 5, min: 65, max: 90 };
      this.rules[62].opcodes[3] = { type: 5, min: 48, max: 57 };
      this.rules[62].opcodes[4] = { type: 4, index: 63 };
      this.rules[62].opcodes[5] = { type: 6, string: [33] };
      this.rules[62].opcodes[6] = { type: 6, string: [36] };
      this.rules[62].opcodes[7] = { type: 5, min: 38, max: 46 };
      this.rules[62].opcodes[8] = { type: 5, min: 58, max: 59 };
      this.rules[62].opcodes[9] = { type: 6, string: [61] };
      this.rules[62].opcodes[10] = { type: 6, string: [64] };
      this.rules[62].opcodes[11] = { type: 6, string: [95] };
      this.rules[62].opcodes[12] = { type: 6, string: [126] };
      this.rules[63].opcodes = [];
      this.rules[63].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[63].opcodes[1] = { type: 6, string: [37] };
      this.rules[63].opcodes[2] = { type: 4, index: 80 };
      this.rules[63].opcodes[3] = { type: 4, index: 80 };
      this.rules[64].opcodes = [];
      this.rules[64].opcodes[0] = { type: 3, min: 4, max: 4 };
      this.rules[64].opcodes[1] = { type: 4, index: 79 };
      this.rules[65].opcodes = [];
      this.rules[65].opcodes[0] = { type: 3, min: 2, max: 2 };
      this.rules[65].opcodes[1] = { type: 4, index: 79 };
      this.rules[66].opcodes = [];
      this.rules[66].opcodes[0] = { type: 3, min: 2, max: 2 };
      this.rules[66].opcodes[1] = { type: 4, index: 79 };
      this.rules[67].opcodes = [];
      this.rules[67].opcodes[0] = { type: 3, min: 2, max: 2 };
      this.rules[67].opcodes[1] = { type: 4, index: 79 };
      this.rules[68].opcodes = [];
      this.rules[68].opcodes[0] = { type: 3, min: 2, max: 2 };
      this.rules[68].opcodes[1] = { type: 4, index: 79 };
      this.rules[69].opcodes = [];
      this.rules[69].opcodes[0] = { type: 3, min: 2, max: 2 };
      this.rules[69].opcodes[1] = { type: 4, index: 79 };
      this.rules[70].opcodes = [];
      this.rules[70].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[70].opcodes[1] = { type: 7, string: [46] };
      this.rules[70].opcodes[2] = { type: 3, min: 1, max: Infinity };
      this.rules[70].opcodes[3] = { type: 4, index: 79 };
      this.rules[71].opcodes = [];
      this.rules[71].opcodes[0] = { type: 2, children: [1, 4, 5, 6] };
      this.rules[71].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[71].opcodes[2] = { type: 7, string: [43] };
      this.rules[71].opcodes[3] = { type: 7, string: [45] };
      this.rules[71].opcodes[4] = { type: 4, index: 67 };
      this.rules[71].opcodes[5] = { type: 7, string: [58] };
      this.rules[71].opcodes[6] = { type: 4, index: 68 };
      this.rules[72].opcodes = [];
      this.rules[72].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[72].opcodes[1] = { type: 7, string: [122] };
      this.rules[72].opcodes[2] = { type: 4, index: 71 };
      this.rules[73].opcodes = [];
      this.rules[73].opcodes[0] = { type: 2, children: [1, 2, 3, 4, 5, 6] };
      this.rules[73].opcodes[1] = { type: 4, index: 67 };
      this.rules[73].opcodes[2] = { type: 7, string: [58] };
      this.rules[73].opcodes[3] = { type: 4, index: 68 };
      this.rules[73].opcodes[4] = { type: 7, string: [58] };
      this.rules[73].opcodes[5] = { type: 4, index: 69 };
      this.rules[73].opcodes[6] = { type: 3, min: 0, max: 1 };
      this.rules[73].opcodes[7] = { type: 4, index: 70 };
      this.rules[74].opcodes = [];
      this.rules[74].opcodes[0] = { type: 2, children: [1, 2, 3, 4, 5] };
      this.rules[74].opcodes[1] = { type: 4, index: 64 };
      this.rules[74].opcodes[2] = { type: 7, string: [45] };
      this.rules[74].opcodes[3] = { type: 4, index: 65 };
      this.rules[74].opcodes[4] = { type: 7, string: [45] };
      this.rules[74].opcodes[5] = { type: 4, index: 66 };
      this.rules[75].opcodes = [];
      this.rules[75].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[75].opcodes[1] = { type: 4, index: 73 };
      this.rules[75].opcodes[2] = { type: 4, index: 72 };
      this.rules[76].opcodes = [];
      this.rules[76].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[76].opcodes[1] = { type: 4, index: 74 };
      this.rules[76].opcodes[2] = { type: 7, string: [116] };
      this.rules[76].opcodes[3] = { type: 4, index: 75 };
      this.rules[77].opcodes = [];
      this.rules[77].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[77].opcodes[1] = { type: 5, min: 65, max: 90 };
      this.rules[77].opcodes[2] = { type: 5, min: 97, max: 122 };
      this.rules[78].opcodes = [];
      this.rules[78].opcodes[0] = { type: 6, string: [10] };
      this.rules[79].opcodes = [];
      this.rules[79].opcodes[0] = { type: 5, min: 48, max: 57 };
      this.rules[80].opcodes = [];
      this.rules[80].opcodes[0] = { type: 1, children: [1, 2, 3] };
      this.rules[80].opcodes[1] = { type: 5, min: 48, max: 57 };
      this.rules[80].opcodes[2] = { type: 5, min: 65, max: 70 };
      this.rules[80].opcodes[3] = { type: 5, min: 97, max: 102 };
      this.toString = function toString() {
        let str = "";
        str += "; LDT 05/06/2024 \n";
        str += "; modified in several significant ways\n";
        str += "; 1) Literal strings are replaced with numbers and ranges (%d32 & %d32-126, etc.) when possible.\n";
        str += ";    TRB and especially TRG operators are much more efficient than TLS operators.\n";
        str += "; 2) Two rules, authority and URI, are used multiple times in different contexts. These rules will be reproduced and renamed\n";
        str += ";    in order to a) recognize the context and b) remove unneccary callback functions for certain contexts.\n";
        str += ";    This will simiplify recognizing contexts AND remove unneccesary callbacks\n";
        str += "; 2.a) domain is defined as authority-d which is identical to authority except that there will be no\n";
        str += ";      callback functions defined on authority-d or any of its *-d components.\n";
        str += "; 2.b) The resource URI is defined as URI-r and its components defined as *-r.\n";
        str += ";      In this way, callback functions can be defined on URI and is components while\n";
        str += ";      leaving URI-r to be parsed identically with no unnecessary callback functions to slow it down.\n";
        str += `; 3) IPv6address does not work because of APG's "first-success disambiguation" and "greedy" repetitions.
`;
        str += ";    IPv6address redefined and validations moved to callback functions (semantic vs syntactic validation)\n";
        str += ";    Redefinition requires negative look-ahead operators, https://en.wikipedia.org/wiki/Syntactic_predicate\n";
        str += ";    That is SABNF instead of simple ABNF.\n";
        str += '; 4) IPv4address fails because of "first-success disambiguation".\n';
        str += ";    This could be fixed with rearrangement of the alternative terms. However, it would still not\n";
        str += ";    accept zero-padded (leading zeros) decimal octets.\n";
        str += ";    Therefore, IPv4address is also done with callback functions and semantic validation.\n";
        str += "; 5) The negative look-ahead operator is also needed in the definition of host to\n";
        str += ";    prevent failure with a reg-name that begins with an IPv4 address.\n";
        str += "; 6) NOTE: host = 1.1.1.256 is a valid host name even though it is an invalid IPv4address.\n";
        str += ";          The IPv4address alternative fails but the reg-name alternative succeeds.\n";
        str += "; 7) The Ethereum spec (https://eips.ethereum.org/EIPS/eip-4361) message format ABNF\n";
        str += ';    allows for empty statements. Because of the "first success disambiguation" of APG\n';
        str += `;    the an explicit "empty-statement" rule is required to match the spec's intent.
`;
        str += "\n";
        str += "\n";
        str += "sign-in-with-ethereum =\n";
        str += '    oscheme domain %s" wants you to sign in with your Ethereum account:" LF\n';
        str += "    address LF\n";
        str += "    ((LF statement LF LF) / empty-statement / (LF LF))\n";
        str += '    %s"URI: " URI LF\n';
        str += '    %s"Version: " version LF\n';
        str += '    %s"Chain ID: " chain-id LF\n';
        str += '    %s"Nonce: " nonce LF\n';
        str += '    %s"Issued At: " issued-at\n';
        str += "    [ LF ex-title expiration-time ]\n";
        str += "    [ LF nb-title not-before ]\n";
        str += "    [ LF ri-title request-id ]\n";
        str += "    [ LF re-title resources ]\n";
        str += 'ex-title        = %s"Expiration Time: "\n';
        str += 'nb-title        = %s"Not Before: "\n';
        str += 'ri-title        = %s"Request ID: "\n';
        str += 're-title        = %s"Resources:"\n';
        str += 'oscheme         = [ ALPHA *( ALPHA / DIGIT / %d43 / %d45-46 ) "://" ]\n';
        str += "domain          = authority-d\n";
        str += 'address         = "0x" 40*40HEXDIG\n';
        str += "    ; Must also conform to captilization\n";
        str += "    ; checksum encoding specified in EIP-55\n";
        str += "    ; where applicable (EOAs).\n";
        str += "\n";
        str += "statement       = 1*( %d97-122 / %d65-90 / %d48-57 / %d32-33 / %d35-36 / %d38-59 / %d61 / %d63-64 / %d91 / %d93 / %d95 / %d126)\n";
        str += "    ; The purpose is to exclude LF (line breaks).\n";
        str += "    ; LDT 10/04/2023: Do you mean %d32-126? All printing characters\n";
        str += "empty-statement = LF LF LF\n";
        str += 'version         = "1"\n';
        str += "nonce           = 8*( ALPHA / DIGIT )\n";
        str += "issued-at       = date-time\n";
        str += "expiration-time = date-time\n";
        str += "not-before      = date-time\n";
        str += "request-id      = *pchar\n";
        str += "chain-id        = 1*DIGIT\n";
        str += "    ; See EIP-155 for valid CHAIN_IDs.\n";
        str += "resources       = *( LF resource )\n";
        str += 'resource        = "- " URI-r\n';
        str += "\n";
        str += "; ------------------------------------------------------------------------------\n";
        str += "; RFC 3986\n";
        str += "\n";
        str += 'URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]\n';
        str += 'hier-part     = "//" authority path-abempty\n';
        str += "              / path-absolute\n";
        str += "              / path-rootless\n";
        str += "              / path-empty\n";
        str += "scheme        = ALPHA *( ALPHA / DIGIT / %d43 / %d45-46 )\n";
        str += 'authority     = [ userinfo-at ] host [ ":" port ]\n';
        str += 'path-abempty  = *( "/" segment )\n';
        str += 'path-absolute = "/" [ segment-nz *( "/" segment ) ]\n';
        str += 'path-rootless = segment-nz *( "/" segment )\n';
        str += 'path-empty    = ""\n';
        str += "userinfo-at   = userinfo %d64\n";
        str += '                ; userinfo redefined to include the "@" so that it will fail without it\n';
        str += "                ; otherwise userinfo can match host and then the parser will backtrack\n";
        str += "                ; incorrectly keeping the captured userinfo phrase\n";
        str += "userinfo      = *(%d97-122 / %d65-90 / %d48-57 / pct-encoded / %d33 / %d36 / %d38-46 / %d58-59 / %d61 / %d95 / %d126)\n";
        str += "host          = IP-literal / (IPv4address !reg-name-char) / reg-name\n";
        str += "                ; negative look-ahead required to prevent IPv4address from being recognized as first part of reg-name\n";
        str += "                ; same fix as https://github.com/garycourt/uri-js/issues/4\n";
        str += 'IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"\n';
        str += 'IPvFuture     = "v" 1*HEXDIG "." 1*( %d97-122 / %d65-90 / %d48-57 / %d33 / %d36 /%d38-46 / %d58-59 /%d61 /%d95 / %d126 )\n';
        str += "IPv6address   = nodcolon / dcolon\n";
        str += "nodcolon      = (h16n *h16cn) [%d58 IPv4address]\n";
        str += "dcolon        = [h16 *h16c] %d58.58 (((h16n *h16cn) [%d58 IPv4address]) / [IPv4address])\n";
        str += "h16           = 1*4HEXDIG\n";
        str += "h16c          = %d58 1*4HEXDIG\n";
        str += "h16n          = 1*4HEXDIG !%d46\n";
        str += "h16cn         = %d58 1*4HEXDIG !%d46\n";
        str += 'IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet\n';
        str += "; Here we will will use callback functions to evaluate and validate the (possibly zero-padded) dec-octet.\n";
        str += "dec-octet     =  *3dec-digit\n";
        str += "dec-digit     = %d48-57\n";
        str += "reg-name      = *reg-name-char\n";
        str += "reg-name-char = %d97-122 / %d65-90 / %d48-57 / pct-encoded / %d33 / %d36 / %d38-46 / %d59 / %d61 /%d95 / %d126\n";
        str += "port          = *DIGIT\n";
        str += "query         = *(pchar / %d47 / %d63)\n";
        str += "fragment      = *(pchar / %d47 / %d63)\n";
        str += "\n";
        str += "; URI-r is a redefiniton of URI but without the callback functions attached to it\n";
        str += "; it reuses athority-d from domain \n";
        str += 'URI-r         = scheme-r ":" hier-part-r [ "?" query-r ] [ "#" fragment-r ]\n';
        str += 'hier-part-r   = "//" authority-d path-abempty-r\n';
        str += "              / path-absolute-r\n";
        str += "              / path-rootless-r\n";
        str += "              / path-empty-r\n";
        str += "scheme-r      = ALPHA *( ALPHA / DIGIT / %d43 / %d45-46 )\n";
        str += "query-r       = *(pchar / %d47 / %d63)\n";
        str += "fragment-r    = *(pchar / %d47 / %d63)\n";
        str += "\n";
        str += "; authority-d is a redefinition of authority for capturing the domian phrase\n";
        str += "; but without callback functions \n";
        str += "; it is reused for URI- for the same reason               \n";
        str += 'authority-d   = [ userinfo-d %d64 ] host-d [ ":" port-d ]\n';
        str += "userinfo-d    = *(%d97-122 / %d65-90 / %d48-57 / pct-encoded / %d33 / %d36 / %d38-46 / %d58-59 / %d61 / %d95 / %d126)\n";
        str += "host-d        = IP-literal / (IPv4address !reg-name-char) / reg-name\n";
        str += "port-d        = *DIGIT\n";
        str += "\n";
        str += "; for use with URI-r\n";
        str += 'path-abempty-r  = *( "/" segment )\n';
        str += 'path-absolute-r = "/" [ segment-nz *( "/" segment ) ]\n';
        str += 'path-rootless-r = segment-nz *( "/" segment )\n';
        str += 'path-empty-r    = ""\n';
        str += "segment       = *pchar\n";
        str += "segment-nz    = 1*pchar\n";
        str += "pchar         = (%d97-122 / %d65-90 / %d48-57 / pct-encoded / %d33 / %d36 / %d38-46 /%d58-59 / %d61 / %d64 / %d95 / %d126)\n";
        str += "pct-encoded   = %d37 HEXDIG HEXDIG\n";
        str += "\n";
        str += "; no longer needed - expanded for all usage for fewer branches in the parse there\n";
        str += "; and more efficient use of the TBS & TRG operators in place of TLS and rule names\n";
        str += '; does not work with APG probably because of "first-success disambiguation" and greedy repetitions.\n';
        str += "; will replace with semantic checking of valid number of h16s\n";
        str += ';IPv6address   =                            6( h16 ":" ) ls32\n';
        str += ';              /                       "::" 5( h16 ":" ) ls32\n';
        str += ';              / [               h16 ] "::" 4( h16 ":" ) ls32\n';
        str += ';              / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32\n';
        str += ';              / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32\n';
        str += ';              / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32\n';
        str += ';              / [ *4( h16 ":" ) h16 ] "::"              ls32\n';
        str += ';              / [ *5( h16 ":" ) h16 ] "::"              h16\n';
        str += ';              / [ *6( h16 ":" ) h16 ] "::"\n';
        str += ';ls32          = ( h16 ":" h16 ) / IPv4address\n';
        str += '; dec-octet does not work because of "first-success disambiguation".\n';
        str += "; Must have the longest (3-digit) numbers first.\n";
        str += "; Even so, this form does not accept leading zeros.\n";
        str += "; There does not seem to be a clear standard for this (https://en.wikipedia.org/wiki/Dot-decimal_notation)\n";
        str += "; however and early RFC 790 did show leading-zero padding of the three digits.\n";
        str += ";dec-octet     = DIGIT                 ; 0-9\n";
        str += ";                 / %x31-39 DIGIT         ; 10-99\n";
        str += ';                 / "1" 2DIGIT            ; 100-199\n';
        str += ';                 / "2" %x30-34 DIGIT     ; 200-249\n';
        str += ';                 / "25" %x30-35          ; 250-255\n';
        str += ';statement = 1*( reserved / unreserved / " " )\n';
        str += ';scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )\n';
        str += ';authority     = [ userinfo "@" ] host [ ":" port ]\n';
        str += ';userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )\n';
        str += ';query         = *( pchar / "/" / "?" )\n';
        str += ';fragment      = *( pchar / "/" / "?" )\n';
        str += ';IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )\n';
        str += ";reg-name      = *( unreserved / pct-encoded / sub-delims )\n";
        str += ';pct-encoded   = "%" HEXDIG HEXDIG\n';
        str += ';pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"\n';
        str += ';path-empty    = 0pchar; deprecated - empty literal string, "", is more efficient \n';
        str += ';unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"\n';
        str += ";reserved      = gen-delims / sub-delims\n";
        str += ';gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"\n';
        str += `;sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
`;
        str += ';              / "*" / "+" / "," / ";" / "="\n';
        str += ';HEXDIG         =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"\n';
        str += "\n";
        str += "; ------------------------------------------------------------------------------\n";
        str += "; RFC 3339\n";
        str += "\n";
        str += "date-fullyear   = 4DIGIT\n";
        str += "date-month      = 2DIGIT  ; 01-12\n";
        str += "date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on\n";
        str += "                          ; month/year\n";
        str += "time-hour       = 2DIGIT  ; 00-23\n";
        str += "time-minute     = 2DIGIT  ; 00-59\n";
        str += "time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second\n";
        str += "                          ; rules\n";
        str += 'time-secfrac    = "." 1*DIGIT\n';
        str += 'time-numoffset  = ("+" / "-") time-hour ":" time-minute\n';
        str += 'time-offset     = "Z" / time-numoffset\n';
        str += "\n";
        str += 'partial-time    = time-hour ":" time-minute ":" time-second\n';
        str += "                  [time-secfrac]\n";
        str += 'full-date       = date-fullyear "-" date-month "-" date-mday\n';
        str += "full-time       = partial-time time-offset\n";
        str += "\n";
        str += 'date-time       = full-date "T" full-time\n';
        str += "\n";
        str += "; ------------------------------------------------------------------------------\n";
        str += "; RFC 5234\n";
        str += "\n";
        str += "ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z\n";
        str += "LF             =  %x0A\n";
        str += "                  ; linefeed\n";
        str += "DIGIT          =  %x30-39\n";
        str += "                  ; 0-9\n";
        str += "HEXDIG         = %d48-57 / %d65-70 / %d97-102\n";
        str += "\n";
        return str;
      };
    }
    exports.grammar = grammar;
  }
});

// node_modules/apg-js/src/apg-lib/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/apg-js/src/apg-lib/identifiers.js"(exports, module) {
    module.exports = {
      // Identifies the operator type. Used by the generator
      // to indicate operator types in the grammar object.
      // Used by the [parser](./parser.html) when interpreting the grammar object.
      /* the original ABNF operators */
      ALT: 1,
      CAT: 2,
      REP: 3,
      RNM: 4,
      TRG: 5,
      TBS: 6,
      TLS: 7,
      /* the super set, SABNF operators */
      UDT: 11,
      AND: 12,
      NOT: 13,
      BKR: 14,
      BKA: 15,
      BKN: 16,
      ABG: 17,
      AEN: 18,
      // Used by the parser and the user's `RNM` and `UDT` callback functions.
      // Identifies the parser state as it traverses the parse tree nodes.
      // - *ACTIVE* - indicates the downward direction through the parse tree node.
      // - *MATCH* - indicates the upward direction and a phrase, of length \> 0, has been successfully matched
      // - *EMPTY* - indicates the upward direction and a phrase, of length = 0, has been successfully matched
      // - *NOMATCH* - indicates the upward direction and the parser failed to match any phrase at all
      ACTIVE: 100,
      MATCH: 101,
      EMPTY: 102,
      NOMATCH: 103,
      // Used by [`AST` translator](./ast.html) (semantic analysis) and the user's callback functions
      // to indicate the direction of flow through the `AST` nodes.
      // - *SEM_PRE* - indicates the downward (pre-branch) direction through the `AST` node.
      // - *SEM_POST* - indicates the upward (post-branch) direction through the `AST` node.
      SEM_PRE: 200,
      SEM_POST: 201,
      // Used by the user's callback functions to indicate to the `AST` translator (semantic analysis) how to proceed.
      // - *SEM_OK* - normal return value
      // - *SEM_SKIP* - if a callback function returns this value from the SEM_PRE state,
      // the translator will skip processing all `AST` nodes in the branch below the current node.
      // Ignored if returned from the SEM_POST state.
      SEM_OK: 300,
      SEM_SKIP: 301,
      // Used in attribute generation to distinguish the necessary attribute categories.
      // - *ATTR_N* - non-recursive
      // - *ATTR_R* - recursive
      // - *ATTR_MR* - belongs to a mutually-recursive set
      ATTR_N: 400,
      ATTR_R: 401,
      ATTR_MR: 402,
      // Look around values indicate whether the parser is in look ahead or look behind mode.
      // Used by the tracing facility to indicate the look around mode in the trace records display.
      // - *LOOKAROUND_NONE* - the parser is in normal parsing mode
      // - *LOOKAROUND_AHEAD* - the parse is in look-ahead mode, phrase matching for operator `AND(&)` or `NOT(!)`
      // - *LOOKAROUND_BEHIND* - the parse is in look-behind mode, phrase matching for operator `BKA(&&)` or `BKN(!!)`
      LOOKAROUND_NONE: 500,
      LOOKAROUND_AHEAD: 501,
      LOOKAROUND_BEHIND: 502,
      // Back reference rule mode indicators
      // - *BKR_MODE_UM* - the back reference is using universal mode
      // - *BKR_MODE_PM* - the back reference is using parent frame mode
      // - *BKR_MODE_CS* - the back reference is using case-sensitive phrase matching
      // - *BKR_MODE_CI* - the back reference is using case-insensitive phrase matching
      BKR_MODE_UM: 601,
      BKR_MODE_PM: 602,
      BKR_MODE_CS: 603,
      BKR_MODE_CI: 604
    };
  }
});

// node_modules/apg-js/src/apg-lib/style.js
var require_style = __commonJS({
  "node_modules/apg-js/src/apg-lib/style.js"(exports, module) {
    module.exports = {
      // Generated by apglib/style.js 
      CLASS_MONOSPACE: "apg-mono",
      CLASS_ACTIVE: "apg-active",
      CLASS_EMPTY: "apg-empty",
      CLASS_MATCH: "apg-match",
      CLASS_NOMATCH: "apg-nomatch",
      CLASS_LOOKAHEAD: "apg-lh-match",
      CLASS_LOOKBEHIND: "apg-lb-match",
      CLASS_REMAINDER: "apg-remainder",
      CLASS_CTRLCHAR: "apg-ctrl-char",
      CLASS_LINEEND: "apg-line-end",
      CLASS_ERROR: "apg-error",
      CLASS_PHRASE: "apg-phrase",
      CLASS_EMPTYPHRASE: "apg-empty-phrase",
      CLASS_STATE: "apg-state",
      CLASS_STATS: "apg-stats",
      CLASS_TRACE: "apg-trace",
      CLASS_GRAMMAR: "apg-grammar",
      CLASS_RULES: "apg-rules",
      CLASS_RULESLINK: "apg-rules-link",
      CLASS_ATTRIBUTES: "apg-attrs"
    };
  }
});

// ../../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../../node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// ../../node_modules/buffer/index.js
var require_buffer = __commonJS({
  "../../node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    function Buffer(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer.alloc(+length);
    }
    Buffer.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer.prototype;
    };
    Buffer.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer.prototype.toLocaleString = Buffer.prototype.toString;
    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer.compare(this, b) === 0;
    };
    Buffer.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    }
    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }
      if (!Buffer.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer.from(val, encoding);
      }
      if (Buffer.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
  }
});

// node_modules/apg-js/src/apg-conv-api/transformers.js
var require_transformers = __commonJS({
  "node_modules/apg-js/src/apg-conv-api/transformers.js"(exports) {
    "use strict;";
    var { Buffer } = require_buffer();
    var NON_SHORTEST = 4294967292;
    var TRAILING = 4294967293;
    var RANGE = 4294967294;
    var ILL_FORMED = 4294967295;
    var mask = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023];
    var ascii = [
      "00",
      "01",
      "02",
      "03",
      "04",
      "05",
      "06",
      "07",
      "08",
      "09",
      "0A",
      "0B",
      "0C",
      "0D",
      "0E",
      "0F",
      "10",
      "11",
      "12",
      "13",
      "14",
      "15",
      "16",
      "17",
      "18",
      "19",
      "1A",
      "1B",
      "1C",
      "1D",
      "1E",
      "1F",
      "20",
      "21",
      "22",
      "23",
      "24",
      "25",
      "26",
      "27",
      "28",
      "29",
      "2A",
      "2B",
      "2C",
      "2D",
      "2E",
      "2F",
      "30",
      "31",
      "32",
      "33",
      "34",
      "35",
      "36",
      "37",
      "38",
      "39",
      "3A",
      "3B",
      "3C",
      "3D",
      "3E",
      "3F",
      "40",
      "41",
      "42",
      "43",
      "44",
      "45",
      "46",
      "47",
      "48",
      "49",
      "4A",
      "4B",
      "4C",
      "4D",
      "4E",
      "4F",
      "50",
      "51",
      "52",
      "53",
      "54",
      "55",
      "56",
      "57",
      "58",
      "59",
      "5A",
      "5B",
      "5C",
      "5D",
      "5E",
      "5F",
      "60",
      "61",
      "62",
      "63",
      "64",
      "65",
      "66",
      "67",
      "68",
      "69",
      "6A",
      "6B",
      "6C",
      "6D",
      "6E",
      "6F",
      "70",
      "71",
      "72",
      "73",
      "74",
      "75",
      "76",
      "77",
      "78",
      "79",
      "7A",
      "7B",
      "7C",
      "7D",
      "7E",
      "7F",
      "80",
      "81",
      "82",
      "83",
      "84",
      "85",
      "86",
      "87",
      "88",
      "89",
      "8A",
      "8B",
      "8C",
      "8D",
      "8E",
      "8F",
      "90",
      "91",
      "92",
      "93",
      "94",
      "95",
      "96",
      "97",
      "98",
      "99",
      "9A",
      "9B",
      "9C",
      "9D",
      "9E",
      "9F",
      "A0",
      "A1",
      "A2",
      "A3",
      "A4",
      "A5",
      "A6",
      "A7",
      "A8",
      "A9",
      "AA",
      "AB",
      "AC",
      "AD",
      "AE",
      "AF",
      "B0",
      "B1",
      "B2",
      "B3",
      "B4",
      "B5",
      "B6",
      "B7",
      "B8",
      "B9",
      "BA",
      "BB",
      "BC",
      "BD",
      "BE",
      "BF",
      "C0",
      "C1",
      "C2",
      "C3",
      "C4",
      "C5",
      "C6",
      "C7",
      "C8",
      "C9",
      "CA",
      "CB",
      "CC",
      "CD",
      "CE",
      "CF",
      "D0",
      "D1",
      "D2",
      "D3",
      "D4",
      "D5",
      "D6",
      "D7",
      "D8",
      "D9",
      "DA",
      "DB",
      "DC",
      "DD",
      "DE",
      "DF",
      "E0",
      "E1",
      "E2",
      "E3",
      "E4",
      "E5",
      "E6",
      "E7",
      "E8",
      "E9",
      "EA",
      "EB",
      "EC",
      "ED",
      "EE",
      "EF",
      "F0",
      "F1",
      "F2",
      "F3",
      "F4",
      "F5",
      "F6",
      "F7",
      "F8",
      "F9",
      "FA",
      "FB",
      "FC",
      "FD",
      "FE",
      "FF"
    ];
    var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("");
    var base64codes = [];
    base64chars.forEach((char) => {
      base64codes.push(char.charCodeAt(0));
    });
    exports.utf8 = {
      encode(chars) {
        const bytes = [];
        chars.forEach((char) => {
          if (char >= 0 && char <= 127) {
            bytes.push(char);
          } else if (char <= 2047) {
            bytes.push(192 + (char >> 6 & mask[5]));
            bytes.push(128 + (char & mask[6]));
          } else if (char < 55296 || char > 57343 && char <= 65535) {
            bytes.push(224 + (char >> 12 & mask[4]));
            bytes.push(128 + (char >> 6 & mask[6]));
            bytes.push(128 + (char & mask[6]));
          } else if (char >= 65536 && char <= 1114111) {
            const u = char >> 16 & mask[5];
            bytes.push(240 + (u >> 2));
            bytes.push(128 + ((u & mask[2]) << 4) + (char >> 12 & mask[4]));
            bytes.push(128 + (char >> 6 & mask[6]));
            bytes.push(128 + (char & mask[6]));
          } else {
            throw new RangeError(`utf8.encode: character out of range: char: ${char}`);
          }
        });
        return Buffer.from(bytes);
      },
      decode(buf, bom) {
        function bytes2(b12, b2) {
          if ((b2 & 192) !== 128) {
            return TRAILING;
          }
          const x = ((b12 & mask[5]) << 6) + (b2 & mask[6]);
          if (x < 128) {
            return NON_SHORTEST;
          }
          return x;
        }
        function bytes3(b12, b2, b3) {
          if ((b3 & 192) !== 128 || (b2 & 192) !== 128) {
            return TRAILING;
          }
          const x = ((b12 & mask[4]) << 12) + ((b2 & mask[6]) << 6) + (b3 & mask[6]);
          if (x < 2048) {
            return NON_SHORTEST;
          }
          if (x >= 55296 && x <= 57343) {
            return RANGE;
          }
          return x;
        }
        function bytes4(b12, b2, b3, b4) {
          if ((b4 & 192) !== 128 || (b3 & 192) !== 128 || (b2 & 192) !== 128) {
            return TRAILING;
          }
          const x = (((b12 & mask[3]) << 2) + (b2 >> 4 & mask[2]) << 16) + ((b2 & mask[4]) << 12) + ((b3 & mask[6]) << 6) + (b4 & mask[6]);
          if (x < 65536) {
            return NON_SHORTEST;
          }
          if (x > 1114111) {
            return RANGE;
          }
          return x;
        }
        let c;
        let b1;
        let i1;
        let i2;
        let i3;
        let inc;
        const len = buf.length;
        let i = bom ? 3 : 0;
        const chars = [];
        while (i < len) {
          b1 = buf[i];
          c = ILL_FORMED;
          const TRUE = true;
          while (TRUE) {
            if (b1 >= 0 && b1 <= 127) {
              c = b1;
              inc = 1;
              break;
            }
            i1 = i + 1;
            if (i1 < len && b1 >= 194 && b1 <= 223) {
              c = bytes2(b1, buf[i1]);
              inc = 2;
              break;
            }
            i2 = i + 2;
            if (i2 < len && b1 >= 224 && b1 <= 239) {
              c = bytes3(b1, buf[i1], buf[i2]);
              inc = 3;
              break;
            }
            i3 = i + 3;
            if (i3 < len && b1 >= 240 && b1 <= 244) {
              c = bytes4(b1, buf[i1], buf[i2], buf[i3]);
              inc = 4;
              break;
            }
            break;
          }
          if (c > 1114111) {
            const at = `byte[${i}]`;
            if (c === ILL_FORMED) {
              throw new RangeError(`utf8.decode: ill-formed UTF8 byte sequence found at: ${at}`);
            }
            if (c === TRAILING) {
              throw new RangeError(`utf8.decode: illegal trailing byte found at: ${at}`);
            }
            if (c === RANGE) {
              throw new RangeError(`utf8.decode: code point out of range found at: ${at}`);
            }
            if (c === NON_SHORTEST) {
              throw new RangeError(`utf8.decode: non-shortest form found at: ${at}`);
            }
            throw new RangeError(`utf8.decode: unrecognized error found at: ${at}`);
          }
          chars.push(c);
          i += inc;
        }
        return chars;
      }
    };
    exports.utf16be = {
      encode(chars) {
        const bytes = [];
        let char;
        let h;
        let l;
        for (let i = 0; i < chars.length; i += 1) {
          char = chars[i];
          if (char >= 0 && char <= 55295 || char >= 57344 && char <= 65535) {
            bytes.push(char >> 8 & mask[8]);
            bytes.push(char & mask[8]);
          } else if (char >= 65536 && char <= 1114111) {
            l = char - 65536;
            h = 55296 + (l >> 10);
            l = 56320 + (l & mask[10]);
            bytes.push(h >> 8 & mask[8]);
            bytes.push(h & mask[8]);
            bytes.push(l >> 8 & mask[8]);
            bytes.push(l & mask[8]);
          } else {
            throw new RangeError(`utf16be.encode: UTF16BE value out of range: char[${i}]: ${char}`);
          }
        }
        return Buffer.from(bytes);
      },
      decode(buf, bom) {
        if (buf.length % 2 > 0) {
          throw new RangeError(`utf16be.decode: data length must be even multiple of 2: length: ${buf.length}`);
        }
        const chars = [];
        const len = buf.length;
        let i = bom ? 2 : 0;
        let j = 0;
        let c;
        let inc;
        let i1;
        let i3;
        let high;
        let low;
        while (i < len) {
          const TRUE = true;
          while (TRUE) {
            i1 = i + 1;
            if (i1 < len) {
              high = (buf[i] << 8) + buf[i1];
              if (high < 55296 || high > 57343) {
                c = high;
                inc = 2;
                break;
              }
              i3 = i + 3;
              if (i3 < len) {
                low = (buf[i + 2] << 8) + buf[i3];
                if (high <= 56319 && low >= 56320 && low <= 57343) {
                  c = 65536 + (high - 55296 << 10) + (low - 56320);
                  inc = 4;
                  break;
                }
              }
            }
            throw new RangeError(`utf16be.decode: ill-formed UTF16BE byte sequence found: byte[${i}]`);
          }
          chars[j++] = c;
          i += inc;
        }
        return chars;
      }
    };
    exports.utf16le = {
      encode(chars) {
        const bytes = [];
        let char;
        let h;
        let l;
        for (let i = 0; i < chars.length; i += 1) {
          char = chars[i];
          if (char >= 0 && char <= 55295 || char >= 57344 && char <= 65535) {
            bytes.push(char & mask[8]);
            bytes.push(char >> 8 & mask[8]);
          } else if (char >= 65536 && char <= 1114111) {
            l = char - 65536;
            h = 55296 + (l >> 10);
            l = 56320 + (l & mask[10]);
            bytes.push(h & mask[8]);
            bytes.push(h >> 8 & mask[8]);
            bytes.push(l & mask[8]);
            bytes.push(l >> 8 & mask[8]);
          } else {
            throw new RangeError(`utf16le.encode: UTF16LE value out of range: char[${i}]: ${char}`);
          }
        }
        return Buffer.from(bytes);
      },
      decode(buf, bom) {
        if (buf.length % 2 > 0) {
          throw new RangeError(`utf16le.decode: data length must be even multiple of 2: length: ${buf.length}`);
        }
        const chars = [];
        const len = buf.length;
        let i = bom ? 2 : 0;
        let j = 0;
        let c;
        let inc;
        let i1;
        let i3;
        let high;
        let low;
        while (i < len) {
          const TRUE = true;
          while (TRUE) {
            i1 = i + 1;
            if (i1 < len) {
              high = (buf[i1] << 8) + buf[i];
              if (high < 55296 || high > 57343) {
                c = high;
                inc = 2;
                break;
              }
              i3 = i + 3;
              if (i3 < len) {
                low = (buf[i3] << 8) + buf[i + 2];
                if (high <= 56319 && low >= 56320 && low <= 57343) {
                  c = 65536 + (high - 55296 << 10) + (low - 56320);
                  inc = 4;
                  break;
                }
              }
            }
            throw new RangeError(`utf16le.decode: ill-formed UTF16LE byte sequence found: byte[${i}]`);
          }
          chars[j++] = c;
          i += inc;
        }
        return chars;
      }
    };
    exports.utf32be = {
      encode(chars) {
        const buf = Buffer.alloc(chars.length * 4);
        let i = 0;
        chars.forEach((char) => {
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32be.encode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);
          }
          buf[i++] = char >> 24 & mask[8];
          buf[i++] = char >> 16 & mask[8];
          buf[i++] = char >> 8 & mask[8];
          buf[i++] = char & mask[8];
        });
        return buf;
      },
      decode(buf, bom) {
        if (buf.length % 4 > 0) {
          throw new RangeError(`utf32be.decode: UTF32BE byte length must be even multiple of 4: length: ${buf.length}`);
        }
        const chars = [];
        let i = bom ? 4 : 0;
        for (; i < buf.length; i += 4) {
          const char = (buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3];
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32be.decode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);
          }
          chars.push(char);
        }
        return chars;
      }
    };
    exports.utf32le = {
      encode(chars) {
        const buf = Buffer.alloc(chars.length * 4);
        let i = 0;
        chars.forEach((char) => {
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);
          }
          buf[i++] = char & mask[8];
          buf[i++] = char >> 8 & mask[8];
          buf[i++] = char >> 16 & mask[8];
          buf[i++] = char >> 24 & mask[8];
        });
        return buf;
      },
      decode(buf, bom) {
        if (buf.length % 4 > 0) {
          throw new RangeError(`utf32be.decode: UTF32LE byte length must be even multiple of 4: length: ${buf.length}`);
        }
        const chars = [];
        let i = bom ? 4 : 0;
        for (; i < buf.length; i += 4) {
          const char = (buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i];
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);
          }
          chars.push(char);
        }
        return chars;
      }
    };
    exports.uint7 = {
      encode(chars) {
        const buf = Buffer.alloc(chars.length);
        for (let i = 0; i < chars.length; i += 1) {
          if (chars[i] > 127) {
            throw new RangeError(`uint7.encode: UINT7 character code out of range: char[${i}]: ${chars[i]}`);
          }
          buf[i] = chars[i];
        }
        return buf;
      },
      decode(buf) {
        const chars = [];
        for (let i = 0; i < buf.length; i += 1) {
          if (buf[i] > 127) {
            throw new RangeError(`uint7.decode: UINT7 character code out of range: byte[${i}]: ${buf[i]}`);
          }
          chars[i] = buf[i];
        }
        return chars;
      }
    };
    exports.uint8 = {
      encode(chars) {
        const buf = Buffer.alloc(chars.length);
        for (let i = 0; i < chars.length; i += 1) {
          if (chars[i] > 255) {
            throw new RangeError(`uint8.encode: UINT8 character code out of range: char[${i}]: ${chars[i]}`);
          }
          buf[i] = chars[i];
        }
        return buf;
      },
      decode(buf) {
        const chars = [];
        for (let i = 0; i < buf.length; i += 1) {
          chars[i] = buf[i];
        }
        return chars;
      }
    };
    exports.uint16be = {
      encode(chars) {
        const buf = Buffer.alloc(chars.length * 2);
        let i = 0;
        chars.forEach((char) => {
          if (char > 65535) {
            throw new RangeError(`uint16be.encode: UINT16BE character code out of range: char[${i / 2}]: ${char}`);
          }
          buf[i++] = char >> 8 & mask[8];
          buf[i++] = char & mask[8];
        });
        return buf;
      },
      decode(buf) {
        if (buf.length % 2 > 0) {
          throw new RangeError(`uint16be.decode: UINT16BE byte length must be even multiple of 2: length: ${buf.length}`);
        }
        const chars = [];
        for (let i = 0; i < buf.length; i += 2) {
          chars.push((buf[i] << 8) + buf[i + 1]);
        }
        return chars;
      }
    };
    exports.uint16le = {
      encode(chars) {
        const buf = Buffer.alloc(chars.length * 2);
        let i = 0;
        chars.forEach((char) => {
          if (char > 65535) {
            throw new RangeError(`uint16le.encode: UINT16LE character code out of range: char[${i / 2}]: ${char}`);
          }
          buf[i++] = char & mask[8];
          buf[i++] = char >> 8 & mask[8];
        });
        return buf;
      },
      decode(buf) {
        if (buf.length % 2 > 0) {
          throw new RangeError(`uint16le.decode: UINT16LE byte length must be even multiple of 2: length: ${buf.length}`);
        }
        const chars = [];
        for (let i = 0; i < buf.length; i += 2) {
          chars.push((buf[i + 1] << 8) + buf[i]);
        }
        return chars;
      }
    };
    exports.uint32be = {
      encode(chars) {
        const buf = Buffer.alloc(chars.length * 4);
        let i = 0;
        chars.forEach((char) => {
          buf[i++] = char >> 24 & mask[8];
          buf[i++] = char >> 16 & mask[8];
          buf[i++] = char >> 8 & mask[8];
          buf[i++] = char & mask[8];
        });
        return buf;
      },
      decode(buf) {
        if (buf.length % 4 > 0) {
          throw new RangeError(`uint32be.decode: UINT32BE byte length must be even multiple of 4: length: ${buf.length}`);
        }
        const chars = [];
        for (let i = 0; i < buf.length; i += 4) {
          chars.push((buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3]);
        }
        return chars;
      }
    };
    exports.uint32le = {
      encode(chars) {
        const buf = Buffer.alloc(chars.length * 4);
        let i = 0;
        chars.forEach((char) => {
          buf[i++] = char & mask[8];
          buf[i++] = char >> 8 & mask[8];
          buf[i++] = char >> 16 & mask[8];
          buf[i++] = char >> 24 & mask[8];
        });
        return buf;
      },
      decode(buf) {
        if (buf.length % 4 > 0) {
          throw new RangeError(`uint32le.decode: UINT32LE byte length must be even multiple of 4: length: ${buf.length}`);
        }
        const chars = [];
        for (let i = 0; i < buf.length; i += 4) {
          chars.push((buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i]);
        }
        return chars;
      }
    };
    exports.string = {
      encode(chars) {
        return exports.utf16le.encode(chars).toString("utf16le");
      },
      decode(str) {
        return exports.utf16le.decode(Buffer.from(str, "utf16le"), 0);
      }
    };
    exports.escaped = {
      // Encodes an Array of 32-bit integers into ESCAPED format.
      encode(chars) {
        const bytes = [];
        for (let i = 0; i < chars.length; i += 1) {
          const char = chars[i];
          if (char === 96) {
            bytes.push(char);
            bytes.push(char);
          } else if (char === 10) {
            bytes.push(char);
          } else if (char >= 32 && char <= 126) {
            bytes.push(char);
          } else {
            let str = "";
            if (char >= 0 && char <= 31) {
              str += `\`x${ascii[char]}`;
            } else if (char >= 127 && char <= 255) {
              str += `\`x${ascii[char]}`;
            } else if (char >= 256 && char <= 65535) {
              str += `\`u${ascii[char >> 8 & mask[8]]}${ascii[char & mask[8]]}`;
            } else if (char >= 65536 && char <= 4294967295) {
              str += "`u{";
              const digit = char >> 24 & mask[8];
              if (digit > 0) {
                str += ascii[digit];
              }
              str += `${ascii[char >> 16 & mask[8]] + ascii[char >> 8 & mask[8]] + ascii[char & mask[8]]}}`;
            } else {
              throw new Error("escape.encode(char): char > 0xffffffff not allowed");
            }
            const buf = Buffer.from(str);
            buf.forEach((b) => {
              bytes.push(b);
            });
          }
        }
        return Buffer.from(bytes);
      },
      // Decodes ESCAPED format from a Buffer of bytes to an Array of 32-bit integers.
      decode(buf) {
        function isHex(hex) {
          if (hex >= 48 && hex <= 57 || hex >= 65 && hex <= 70 || hex >= 97 && hex <= 102) {
            return true;
          }
          return false;
        }
        function getx(i2, len2, bufArg) {
          const ret2 = { char: null, nexti: i2 + 2, error: true };
          if (i2 + 1 < len2) {
            if (isHex(bufArg[i2]) && isHex(bufArg[i2 + 1])) {
              const str = String.fromCodePoint(bufArg[i2], bufArg[i2 + 1]);
              ret2.char = parseInt(str, 16);
              if (!Number.isNaN(ret2.char)) {
                ret2.error = false;
              }
            }
          }
          return ret2;
        }
        function getu(i2, len2, bufArg) {
          const ret2 = { char: null, nexti: i2 + 4, error: true };
          if (i2 + 3 < len2) {
            if (isHex(bufArg[i2]) && isHex(bufArg[i2 + 1]) && isHex(bufArg[i2 + 2]) && isHex(bufArg[i2 + 3])) {
              const str = String.fromCodePoint(bufArg[i2], bufArg[i2 + 1], bufArg[i2 + 2], bufArg[i2 + 3]);
              ret2.char = parseInt(str, 16);
              if (!Number.isNaN(ret2.char)) {
                ret2.error = false;
              }
            }
          }
          return ret2;
        }
        function getU(i2, len2, bufArg) {
          const ret2 = { char: null, nexti: i2 + 4, error: true };
          let str = "";
          while (i2 < len2 && isHex(bufArg[i2])) {
            str += String.fromCodePoint(bufArg[i2]);
            i2 += 1;
          }
          ret2.char = parseInt(str, 16);
          if (bufArg[i2] === 125 && !Number.isNaN(ret2.char)) {
            ret2.error = false;
          }
          ret2.nexti = i2 + 1;
          return ret2;
        }
        const chars = [];
        const len = buf.length;
        let i1;
        let ret;
        let error;
        let i = 0;
        while (i < len) {
          const TRUE = true;
          while (TRUE) {
            error = true;
            if (buf[i] !== 96) {
              chars.push(buf[i]);
              i += 1;
              error = false;
              break;
            }
            i1 = i + 1;
            if (i1 >= len) {
              break;
            }
            if (buf[i1] === 96) {
              chars.push(96);
              i += 2;
              error = false;
              break;
            }
            if (buf[i1] === 120) {
              ret = getx(i1 + 1, len, buf);
              if (ret.error) {
                break;
              }
              chars.push(ret.char);
              i = ret.nexti;
              error = false;
              break;
            }
            if (buf[i1] === 117) {
              if (buf[i1 + 1] === 123) {
                ret = getU(i1 + 2, len, buf);
                if (ret.error) {
                  break;
                }
                chars.push(ret.char);
                i = ret.nexti;
                error = false;
                break;
              }
              ret = getu(i1 + 1, len, buf);
              if (ret.error) {
                break;
              }
              chars.push(ret.char);
              i = ret.nexti;
              error = false;
              break;
            }
            break;
          }
          if (error) {
            throw new Error(`escaped.decode: ill-formed escape sequence at buf[${i}]`);
          }
        }
        return chars;
      }
    };
    var CR = 13;
    var LF = 10;
    exports.lineEnds = {
      crlf(chars) {
        const lfchars = [];
        let i = 0;
        while (i < chars.length) {
          switch (chars[i]) {
            case CR:
              if (i + 1 < chars.length && chars[i + 1] === LF) {
                i += 2;
              } else {
                i += 1;
              }
              lfchars.push(CR);
              lfchars.push(LF);
              break;
            case LF:
              lfchars.push(CR);
              lfchars.push(LF);
              i += 1;
              break;
            default:
              lfchars.push(chars[i]);
              i += 1;
              break;
          }
        }
        if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {
          lfchars.push(CR);
          lfchars.push(LF);
        }
        return lfchars;
      },
      lf(chars) {
        const lfchars = [];
        let i = 0;
        while (i < chars.length) {
          switch (chars[i]) {
            case CR:
              if (i + 1 < chars.length && chars[i + 1] === LF) {
                i += 2;
              } else {
                i += 1;
              }
              lfchars.push(LF);
              break;
            case LF:
              lfchars.push(LF);
              i += 1;
              break;
            default:
              lfchars.push(chars[i]);
              i += 1;
              break;
          }
        }
        if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {
          lfchars.push(LF);
        }
        return lfchars;
      }
    };
    exports.base64 = {
      encode(buf) {
        if (buf.length === 0) {
          return Buffer.alloc(0);
        }
        let i;
        let j;
        let n;
        let tail = buf.length % 3;
        tail = tail > 0 ? 3 - tail : 0;
        let units = (buf.length + tail) / 3;
        const base64 = Buffer.alloc(units * 4);
        if (tail > 0) {
          units -= 1;
        }
        i = 0;
        j = 0;
        for (let u = 0; u < units; u += 1) {
          n = buf[i++] << 16;
          n += buf[i++] << 8;
          n += buf[i++];
          base64[j++] = base64codes[n >> 18 & mask[6]];
          base64[j++] = base64codes[n >> 12 & mask[6]];
          base64[j++] = base64codes[n >> 6 & mask[6]];
          base64[j++] = base64codes[n & mask[6]];
        }
        if (tail === 0) {
          return base64;
        }
        if (tail === 1) {
          n = buf[i++] << 16;
          n += buf[i] << 8;
          base64[j++] = base64codes[n >> 18 & mask[6]];
          base64[j++] = base64codes[n >> 12 & mask[6]];
          base64[j++] = base64codes[n >> 6 & mask[6]];
          base64[j] = base64codes[64];
          return base64;
        }
        if (tail === 2) {
          n = buf[i] << 16;
          base64[j++] = base64codes[n >> 18 & mask[6]];
          base64[j++] = base64codes[n >> 12 & mask[6]];
          base64[j++] = base64codes[64];
          base64[j] = base64codes[64];
          return base64;
        }
        return void 0;
      },
      decode(codes) {
        function validate(buf2) {
          const chars = [];
          let tail2 = 0;
          for (let i2 = 0; i2 < buf2.length; i2 += 1) {
            const char = buf2[i2];
            const TRUE = true;
            while (TRUE) {
              if (char === 32 || char === 9 || char === 10 || char === 13) {
                break;
              }
              if (char >= 65 && char <= 90) {
                chars.push(char - 65);
                break;
              }
              if (char >= 97 && char <= 122) {
                chars.push(char - 71);
                break;
              }
              if (char >= 48 && char <= 57) {
                chars.push(char + 4);
                break;
              }
              if (char === 43) {
                chars.push(62);
                break;
              }
              if (char === 47) {
                chars.push(63);
                break;
              }
              if (char === 61) {
                chars.push(64);
                tail2 += 1;
                break;
              }
              throw new RangeError(`base64.decode: invalid character buf[${i2}]: ${char}`);
            }
          }
          if (chars.length % 4 > 0) {
            throw new RangeError(`base64.decode: string length not integral multiple of 4: ${chars.length}`);
          }
          switch (tail2) {
            case 0:
              break;
            case 1:
              if (chars[chars.length - 1] !== 64) {
                throw new RangeError("base64.decode: one tail character found: not last character");
              }
              break;
            case 2:
              if (chars[chars.length - 1] !== 64 || chars[chars.length - 2] !== 64) {
                throw new RangeError("base64.decode: two tail characters found: not last characters");
              }
              break;
            default:
              throw new RangeError(`base64.decode: more than two tail characters found: ${tail2}`);
          }
          return { tail: tail2, buf: Buffer.from(chars) };
        }
        if (codes.length === 0) {
          return Buffer.alloc(0);
        }
        const val = validate(codes);
        const { tail } = val;
        const base64 = val.buf;
        let i;
        let j;
        let n;
        let units = base64.length / 4;
        const buf = Buffer.alloc(units * 3 - tail);
        if (tail > 0) {
          units -= 1;
        }
        j = 0;
        i = 0;
        for (let u = 0; u < units; u += 1) {
          n = base64[i++] << 18;
          n += base64[i++] << 12;
          n += base64[i++] << 6;
          n += base64[i++];
          buf[j++] = n >> 16 & mask[8];
          buf[j++] = n >> 8 & mask[8];
          buf[j++] = n & mask[8];
        }
        if (tail === 1) {
          n = base64[i++] << 18;
          n += base64[i++] << 12;
          n += base64[i] << 6;
          buf[j++] = n >> 16 & mask[8];
          buf[j] = n >> 8 & mask[8];
        }
        if (tail === 2) {
          n = base64[i++] << 18;
          n += base64[i++] << 12;
          buf[j] = n >> 16 & mask[8];
        }
        return buf;
      },
      // Converts a base 64 Buffer of bytes to a JavaScript string with line breaks.
      toString(buf) {
        if (buf.length % 4 > 0) {
          throw new RangeError(`base64.toString: input buffer length not multiple of 4: ${buf.length}`);
        }
        let str = "";
        let lineLen = 0;
        function buildLine(c1, c2, c3, c4) {
          switch (lineLen) {
            case 76:
              str += `\r
${c1}${c2}${c3}${c4}`;
              lineLen = 4;
              break;
            case 75:
              str += `${c1}\r
${c2}${c3}${c4}`;
              lineLen = 3;
              break;
            case 74:
              str += `${c1 + c2}\r
${c3}${c4}`;
              lineLen = 2;
              break;
            case 73:
              str += `${c1 + c2 + c3}\r
${c4}`;
              lineLen = 1;
              break;
            default:
              str += c1 + c2 + c3 + c4;
              lineLen += 4;
              break;
          }
        }
        function validate(c) {
          if (c >= 65 && c <= 90) {
            return true;
          }
          if (c >= 97 && c <= 122) {
            return true;
          }
          if (c >= 48 && c <= 57) {
            return true;
          }
          if (c === 43) {
            return true;
          }
          if (c === 47) {
            return true;
          }
          if (c === 61) {
            return true;
          }
          return false;
        }
        for (let i = 0; i < buf.length; i += 4) {
          for (let j = i; j < i + 4; j += 1) {
            if (!validate(buf[j])) {
              throw new RangeError(`base64.toString: buf[${j}]: ${buf[j]} : not valid base64 character code`);
            }
          }
          buildLine(
            String.fromCharCode(buf[i]),
            String.fromCharCode(buf[i + 1]),
            String.fromCharCode(buf[i + 2]),
            String.fromCharCode(buf[i + 3])
          );
        }
        return str;
      }
    };
  }
});

// node_modules/apg-js/src/apg-conv-api/converter.js
var require_converter = __commonJS({
  "node_modules/apg-js/src/apg-conv-api/converter.js"(exports) {
    "use strict;";
    var { Buffer } = require_buffer();
    var trans = require_transformers();
    var UTF8 = "UTF8";
    var UTF16 = "UTF16";
    var UTF16BE = "UTF16BE";
    var UTF16LE = "UTF16LE";
    var UTF32 = "UTF32";
    var UTF32BE = "UTF32BE";
    var UTF32LE = "UTF32LE";
    var UINT7 = "UINT7";
    var ASCII = "ASCII";
    var BINARY = "BINARY";
    var UINT8 = "UINT8";
    var UINT16 = "UINT16";
    var UINT16LE = "UINT16LE";
    var UINT16BE = "UINT16BE";
    var UINT32 = "UINT32";
    var UINT32LE = "UINT32LE";
    var UINT32BE = "UINT32BE";
    var ESCAPED = "ESCAPED";
    var STRING = "STRING";
    var bom8 = function bom82(src) {
      src.type = UTF8;
      const buf = src.data;
      src.bom = 0;
      if (buf.length >= 3) {
        if (buf[0] === 239 && buf[1] === 187 && buf[2] === 191) {
          src.bom = 3;
        }
      }
    };
    var bom16 = function bom162(src) {
      const buf = src.data;
      src.bom = 0;
      switch (src.type) {
        case UTF16:
          src.type = UTF16BE;
          if (buf.length >= 2) {
            if (buf[0] === 254 && buf[1] === 255) {
              src.bom = 2;
            } else if (buf[0] === 255 && buf[1] === 254) {
              src.type = UTF16LE;
              src.bom = 2;
            }
          }
          break;
        case UTF16BE:
          src.type = UTF16BE;
          if (buf.length >= 2) {
            if (buf[0] === 254 && buf[1] === 255) {
              src.bom = 2;
            } else if (buf[0] === 255 && buf[1] === 254) {
              throw new TypeError(`src type: "${UTF16BE}" specified but BOM is for "${UTF16LE}"`);
            }
          }
          break;
        case UTF16LE:
          src.type = UTF16LE;
          if (buf.length >= 0) {
            if (buf[0] === 254 && buf[1] === 255) {
              throw new TypeError(`src type: "${UTF16LE}" specified but BOM is for "${UTF16BE}"`);
            } else if (buf[0] === 255 && buf[1] === 254) {
              src.bom = 2;
            }
          }
          break;
        default:
          throw new TypeError(`UTF16 BOM: src type "${src.type}" unrecognized`);
      }
    };
    var bom32 = function bom322(src) {
      const buf = src.data;
      src.bom = 0;
      switch (src.type) {
        case UTF32:
          src.type = UTF32BE;
          if (buf.length >= 4) {
            if (buf[0] === 0 && buf[1] === 0 && buf[2] === 254 && buf[3] === 255) {
              src.bom = 4;
            }
            if (buf[0] === 255 && buf[1] === 254 && buf[2] === 0 && buf[3] === 0) {
              src.type = UTF32LE;
              src.bom = 4;
            }
          }
          break;
        case UTF32BE:
          src.type = UTF32BE;
          if (buf.length >= 4) {
            if (buf[0] === 0 && buf[1] === 0 && buf[2] === 254 && buf[3] === 255) {
              src.bom = 4;
            }
            if (buf[0] === 255 && buf[1] === 254 && buf[2] === 0 && buf[3] === 0) {
              throw new TypeError(`src type: ${UTF32BE} specified but BOM is for ${UTF32LE}"`);
            }
          }
          break;
        case UTF32LE:
          src.type = UTF32LE;
          if (buf.length >= 4) {
            if (buf[0] === 0 && buf[1] === 0 && buf[2] === 254 && buf[3] === 255) {
              throw new TypeError(`src type: "${UTF32LE}" specified but BOM is for "${UTF32BE}"`);
            }
            if (buf[0] === 255 && buf[1] === 254 && buf[2] === 0 && buf[3] === 0) {
              src.bom = 4;
            }
          }
          break;
        default:
          throw new TypeError(`UTF32 BOM: src type "${src.type}" unrecognized`);
      }
    };
    var validateSrc = function validateSrc2(type, data) {
      function getType(typeArg) {
        const ret2 = {
          type: "",
          base64: false
        };
        const rx = /^(base64:)?([a-zA-Z0-9]+)$/i;
        const result = rx.exec(typeArg);
        if (result) {
          if (result[2]) {
            ret2.type = result[2].toUpperCase();
          }
          if (result[1]) {
            ret2.base64 = true;
          }
        }
        return ret2;
      }
      const ret = getType(type.toUpperCase());
      if (ret.base64) {
        if (ret.type === STRING) {
          throw new TypeError(`type: "${type} "BASE64:" prefix not allowed with type ${STRING}`);
        }
        if (Buffer.isBuffer(data)) {
          ret.data = trans.base64.decode(data);
        } else if (typeof data === "string") {
          const buf = Buffer.from(data, "ascii");
          ret.data = trans.base64.decode(buf);
        } else {
          throw new TypeError(`type: "${type} unrecognized data type: typeof(data): ${typeof data}`);
        }
      } else {
        ret.data = data;
      }
      switch (ret.type) {
        case UTF8:
          bom8(ret);
          break;
        case UTF16:
        case UTF16BE:
        case UTF16LE:
          bom16(ret);
          break;
        case UTF32:
        case UTF32BE:
        case UTF32LE:
          bom32(ret);
          break;
        case UINT16:
          ret.type = UINT16BE;
          break;
        case UINT32:
          ret.type = UINT32BE;
          break;
        case ASCII:
          ret.type = UINT7;
          break;
        case BINARY:
          ret.type = UINT8;
          break;
        case UINT7:
        case UINT8:
        case UINT16LE:
        case UINT16BE:
        case UINT32LE:
        case UINT32BE:
        case STRING:
        case ESCAPED:
          break;
        default:
          throw new TypeError(`type: "${type}" not recognized`);
      }
      if (ret.type === STRING) {
        if (typeof ret.data !== "string") {
          throw new TypeError(`type: "${type}" but data is not a string`);
        }
      } else if (!Buffer.isBuffer(ret.data)) {
        throw new TypeError(`type: "${type}" but data is not a Buffer`);
      }
      return ret;
    };
    var validateDst = function validateDst2(type, chars) {
      function getType(typeArg) {
        let fix;
        let rem;
        const ret2 = {
          crlf: false,
          lf: false,
          base64: false,
          type: ""
        };
        const TRUE = true;
        while (TRUE) {
          rem = typeArg;
          fix = typeArg.slice(0, 5);
          if (fix === "CRLF:") {
            ret2.crlf = true;
            rem = typeArg.slice(5);
            break;
          }
          fix = typeArg.slice(0, 3);
          if (fix === "LF:") {
            ret2.lf = true;
            rem = typeArg.slice(3);
            break;
          }
          break;
        }
        fix = rem.split(":");
        if (fix.length === 1) {
          ret2.type = fix[0];
        } else if (fix.length === 2 && fix[1] === "BASE64") {
          ret2.base64 = true;
          ret2.type = fix[0];
        }
        return ret2;
      }
      if (!Array.isArray(chars)) {
        throw new TypeError(`dst chars: not array: "${typeof chars}`);
      }
      if (typeof type !== "string") {
        throw new TypeError(`dst type: not string: "${typeof type}`);
      }
      const ret = getType(type.toUpperCase());
      switch (ret.type) {
        case UTF8:
        case UTF16BE:
        case UTF16LE:
        case UTF32BE:
        case UTF32LE:
        case UINT7:
        case UINT8:
        case UINT16LE:
        case UINT16BE:
        case UINT32LE:
        case UINT32BE:
        case ESCAPED:
          break;
        case STRING:
          if (ret.base64) {
            throw new TypeError(`":BASE64" suffix not allowed with type ${STRING}`);
          }
          break;
        case ASCII:
          ret.type = UINT7;
          break;
        case BINARY:
          ret.type = UINT8;
          break;
        case UTF16:
          ret.type = UTF16BE;
          break;
        case UTF32:
          ret.type = UTF32BE;
          break;
        case UINT16:
          ret.type = UINT16BE;
          break;
        case UINT32:
          ret.type = UINT32BE;
          break;
        default:
          throw new TypeError(`dst type unrecognized: "${type}" : must have form [crlf:|lf:]type[:base64]`);
      }
      return ret;
    };
    var encode = function encode2(type, chars) {
      switch (type) {
        case UTF8:
          return trans.utf8.encode(chars);
        case UTF16BE:
          return trans.utf16be.encode(chars);
        case UTF16LE:
          return trans.utf16le.encode(chars);
        case UTF32BE:
          return trans.utf32be.encode(chars);
        case UTF32LE:
          return trans.utf32le.encode(chars);
        case UINT7:
          return trans.uint7.encode(chars);
        case UINT8:
          return trans.uint8.encode(chars);
        case UINT16BE:
          return trans.uint16be.encode(chars);
        case UINT16LE:
          return trans.uint16le.encode(chars);
        case UINT32BE:
          return trans.uint32be.encode(chars);
        case UINT32LE:
          return trans.uint32le.encode(chars);
        case STRING:
          return trans.string.encode(chars);
        case ESCAPED:
          return trans.escaped.encode(chars);
        default:
          throw new TypeError(`encode type "${type}" not recognized`);
      }
    };
    var decode = function decode2(src) {
      switch (src.type) {
        case UTF8:
          return trans.utf8.decode(src.data, src.bom);
        case UTF16LE:
          return trans.utf16le.decode(src.data, src.bom);
        case UTF16BE:
          return trans.utf16be.decode(src.data, src.bom);
        case UTF32BE:
          return trans.utf32be.decode(src.data, src.bom);
        case UTF32LE:
          return trans.utf32le.decode(src.data, src.bom);
        case UINT7:
          return trans.uint7.decode(src.data);
        case UINT8:
          return trans.uint8.decode(src.data);
        case UINT16BE:
          return trans.uint16be.decode(src.data);
        case UINT16LE:
          return trans.uint16le.decode(src.data);
        case UINT32BE:
          return trans.uint32be.decode(src.data);
        case UINT32LE:
          return trans.uint32le.decode(src.data);
        case STRING:
          return trans.string.decode(src.data);
        case ESCAPED:
          return trans.escaped.decode(src.data);
        default:
          throw new TypeError(`decode type "${src.type}" not recognized`);
      }
    };
    exports.decode = function exportsDecode(type, data) {
      const src = validateSrc(type, data);
      return decode(src);
    };
    exports.encode = function exportsEncode(type, chars) {
      let c;
      let buf;
      const dst = validateDst(type, chars);
      if (dst.crlf) {
        c = trans.lineEnds.crlf(chars);
        buf = encode(dst.type, c);
      } else if (dst.lf) {
        c = trans.lineEnds.lf(chars);
        buf = encode(dst.type, c);
      } else {
        buf = encode(dst.type, chars);
      }
      if (dst.base64) {
        buf = trans.base64.encode(buf);
      }
      return buf;
    };
    var convert = function convert2(srcType, srcData, dstType) {
      return exports.encode(dstType, exports.decode(srcType, srcData));
    };
    exports.convert = convert;
  }
});

// node_modules/apg-js/src/apg-lib/emitcss.js
var require_emitcss = __commonJS({
  "node_modules/apg-js/src/apg-lib/emitcss.js"(exports, module) {
    module.exports = function emittcss() {
      return "/* This file automatically generated by jsonToless() and LESS. */\n.apg-mono {\n  font-family: monospace;\n}\n.apg-active {\n  font-weight: bold;\n  color: #000000;\n}\n.apg-match {\n  font-weight: bold;\n  color: #264BFF;\n}\n.apg-empty {\n  font-weight: bold;\n  color: #0fbd0f;\n}\n.apg-nomatch {\n  font-weight: bold;\n  color: #FF4000;\n}\n.apg-lh-match {\n  font-weight: bold;\n  color: #1A97BA;\n}\n.apg-lb-match {\n  font-weight: bold;\n  color: #5F1687;\n}\n.apg-remainder {\n  font-weight: bold;\n  color: #999999;\n}\n.apg-ctrl-char {\n  font-weight: bolder;\n  font-style: italic;\n  font-size: 0.6em;\n}\n.apg-line-end {\n  font-weight: bold;\n  color: #000000;\n}\n.apg-error {\n  font-weight: bold;\n  color: #FF4000;\n}\n.apg-phrase {\n  color: #000000;\n  background-color: #8caae6;\n}\n.apg-empty-phrase {\n  color: #0fbd0f;\n}\ntable.apg-state {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: left;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-state th,\ntable.apg-state td {\n  text-align: left;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-state th:nth-last-child(2),\ntable.apg-state td:nth-last-child(2) {\n  text-align: right;\n}\ntable.apg-state caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-stats {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-stats th,\ntable.apg-stats td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-stats caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-trace {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-trace caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-trace th,\ntable.apg-trace td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-trace th:last-child,\ntable.apg-trace th:nth-last-child(2),\ntable.apg-trace td:last-child,\ntable.apg-trace td:nth-last-child(2) {\n  text-align: left;\n}\ntable.apg-grammar {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-grammar caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-grammar th,\ntable.apg-grammar td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-grammar th:last-child,\ntable.apg-grammar td:last-child {\n  text-align: left;\n}\ntable.apg-rules {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-rules caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-rules th,\ntable.apg-rules td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-rules a {\n  color: #003399 !important;\n}\ntable.apg-rules a:hover {\n  color: #8caae6 !important;\n}\ntable.apg-attrs {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: center;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-attrs caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-attrs th,\ntable.apg-attrs td {\n  text-align: center;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-attrs th:nth-child(1),\ntable.apg-attrs th:nth-child(2),\ntable.apg-attrs th:nth-child(3) {\n  text-align: right;\n}\ntable.apg-attrs td:nth-child(1),\ntable.apg-attrs td:nth-child(2),\ntable.apg-attrs td:nth-child(3) {\n  text-align: right;\n}\ntable.apg-attrs a {\n  color: #003399 !important;\n}\ntable.apg-attrs a:hover {\n  color: #8caae6 !important;\n}\n";
    };
  }
});

// node_modules/apg-js/src/apg-lib/utilities.js
var require_utilities = __commonJS({
  "node_modules/apg-js/src/apg-lib/utilities.js"(exports) {
    var style = require_style();
    var converter = require_converter();
    var emitCss = require_emitcss();
    var id = require_identifiers();
    var thisFileName = "utilities.js: ";
    var getBounds = function(length, begArg, len) {
      let end;
      let beg = begArg;
      const TRUE = true;
      while (TRUE) {
        if (length <= 0) {
          beg = 0;
          end = 0;
          break;
        }
        if (typeof beg !== "number") {
          beg = 0;
          end = length;
          break;
        }
        if (beg >= length) {
          beg = length;
          end = length;
          break;
        }
        if (typeof len !== "number") {
          end = length;
          break;
        }
        end = beg + len;
        if (end > length) {
          end = length;
          break;
        }
        break;
      }
      return {
        beg,
        end
      };
    };
    exports.htmlToPage = function(html, titleArg) {
      let title;
      if (typeof html !== "string") {
        throw new Error(`${thisFileName}htmlToPage: input HTML is not a string`);
      }
      if (typeof titleArg !== "string") {
        title = "htmlToPage";
      } else {
        title = titleArg;
      }
      let page = "";
      page += "<!DOCTYPE html>\n";
      page += '<html lang="en">\n';
      page += "<head>\n";
      page += '<meta charset="utf-8">\n';
      page += `<title>${title}</title>
`;
      page += "<style>\n";
      page += emitCss();
      page += "</style>\n";
      page += "</head>\n<body>\n";
      page += `<p>${/* @__PURE__ */ new Date()}</p>
`;
      page += html;
      page += "</body>\n</html>\n";
      return page;
    };
    exports.parserResultToHtml = function(result, caption) {
      let cap = null;
      if (typeof caption === "string" && caption !== "") {
        cap = caption;
      }
      let success;
      let state;
      if (result.success === true) {
        success = `<span class="${style.CLASS_MATCH}">true</span>`;
      } else {
        success = `<span class="${style.CLASS_NOMATCH}">false</span>`;
      }
      if (result.state === id.EMPTY) {
        state = `<span class="${style.CLASS_EMPTY}">EMPTY</span>`;
      } else if (result.state === id.MATCH) {
        state = `<span class="${style.CLASS_MATCH}">MATCH</span>`;
      } else if (result.state === id.NOMATCH) {
        state = `<span class="${style.CLASS_NOMATCH}">NOMATCH</span>`;
      } else {
        state = `<span class="${style.CLASS_NOMATCH}">unrecognized</span>`;
      }
      let html = "";
      html += `<table class="${style.CLASS_STATE}">
`;
      if (cap) {
        html += `<caption>${cap}</caption>
`;
      }
      html += "<tr><th>state item</th><th>value</th><th>description</th></tr>\n";
      html += `<tr><td>parser success</td><td>${success}</td>
`;
      html += `<td><span class="${style.CLASS_MATCH}">true</span> if the parse succeeded,
`;
      html += ` <span class="${style.CLASS_NOMATCH}">false</span> otherwise`;
      html += "<br><i>NOTE: for success, entire string must be matched</i></td></tr>\n";
      html += `<tr><td>parser state</td><td>${state}</td>
`;
      html += `<td><span class="${style.CLASS_EMPTY}">EMPTY</span>, `;
      html += `<span class="${style.CLASS_MATCH}">MATCH</span> or 
`;
      html += `<span class="${style.CLASS_NOMATCH}">NOMATCH</span></td></tr>
`;
      html += `<tr><td>string length</td><td>${result.length}</td><td>length of the input (sub)string</td></tr>
`;
      html += `<tr><td>matched length</td><td>${result.matched}</td><td>number of input string characters matched</td></tr>
`;
      html += `<tr><td>max matched</td><td>${result.maxMatched}</td><td>maximum number of input string characters matched</td></tr>
`;
      html += `<tr><td>max tree depth</td><td>${result.maxTreeDepth}</td><td>maximum depth of the parse tree reached</td></tr>
`;
      html += `<tr><td>node hits</td><td>${result.nodeHits}</td><td>number of parse tree node hits (opcode function calls)</td></tr>
`;
      html += `<tr><td>input length</td><td>${result.inputLength}</td><td>length of full input string</td></tr>
`;
      html += `<tr><td>sub-string begin</td><td>${result.subBegin}</td><td>sub-string first character index</td></tr>
`;
      html += `<tr><td>sub-string end</td><td>${result.subEnd}</td><td>sub-string end-of-string index</td></tr>
`;
      html += `<tr><td>sub-string length</td><td>${result.subLength}</td><td>sub-string length</td></tr>
`;
      html += "</table>\n";
      return html;
    };
    exports.charsToString = function(chars, phraseIndex, phraseLength) {
      let beg;
      let end;
      if (typeof phraseIndex === "number") {
        if (phraseIndex >= chars.length) {
          return "";
        }
        beg = phraseIndex < 0 ? 0 : phraseIndex;
      } else {
        beg = 0;
      }
      if (typeof phraseLength === "number") {
        if (phraseLength <= 0) {
          return "";
        }
        end = phraseLength > chars.length - beg ? chars.length : beg + phraseLength;
      } else {
        end = chars.length;
      }
      if (beg < end) {
        return converter.encode("UTF16LE", chars.slice(beg, end)).toString("utf16le");
      }
      return "";
    };
    exports.stringToChars = function(string) {
      return converter.decode("STRING", string);
    };
    exports.opcodeToString = function(type) {
      let ret = "unknown";
      switch (type) {
        case id.ALT:
          ret = "ALT";
          break;
        case id.CAT:
          ret = "CAT";
          break;
        case id.RNM:
          ret = "RNM";
          break;
        case id.UDT:
          ret = "UDT";
          break;
        case id.AND:
          ret = "AND";
          break;
        case id.NOT:
          ret = "NOT";
          break;
        case id.REP:
          ret = "REP";
          break;
        case id.TRG:
          ret = "TRG";
          break;
        case id.TBS:
          ret = "TBS";
          break;
        case id.TLS:
          ret = "TLS";
          break;
        case id.BKR:
          ret = "BKR";
          break;
        case id.BKA:
          ret = "BKA";
          break;
        case id.BKN:
          ret = "BKN";
          break;
        case id.ABG:
          ret = "ABG";
          break;
        case id.AEN:
          ret = "AEN";
          break;
        default:
          throw new Error("unrecognized opcode");
      }
      return ret;
    };
    exports.stateToString = function(state) {
      let ret = "unknown";
      switch (state) {
        case id.ACTIVE:
          ret = "ACTIVE";
          break;
        case id.MATCH:
          ret = "MATCH";
          break;
        case id.EMPTY:
          ret = "EMPTY";
          break;
        case id.NOMATCH:
          ret = "NOMATCH";
          break;
        default:
          throw new Error("unrecognized state");
      }
      return ret;
    };
    exports.asciiChars = [
      "NUL",
      "SOH",
      "STX",
      "ETX",
      "EOT",
      "ENQ",
      "ACK",
      "BEL",
      "BS",
      "TAB",
      "LF",
      "VT",
      "FF",
      "CR",
      "SO",
      "SI",
      "DLE",
      "DC1",
      "DC2",
      "DC3",
      "DC4",
      "NAK",
      "SYN",
      "ETB",
      "CAN",
      "EM",
      "SUB",
      "ESC",
      "FS",
      "GS",
      "RS",
      "US",
      "&nbsp;",
      "!",
      "&#34;",
      "#",
      "$",
      "%",
      "&#38;",
      "&#39;",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      ":",
      ";",
      "&#60;",
      "=",
      "&#62;",
      "?",
      "@",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "[",
      "&#92;",
      "]",
      "^",
      "_",
      "`",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "{",
      "|",
      "}",
      "~",
      "DEL"
    ];
    exports.charToHex = function(char) {
      let ch = char.toString(16).toUpperCase();
      switch (ch.length) {
        case 1:
        case 3:
        case 7:
          ch = `0${ch}`;
          break;
        case 2:
        case 6:
          ch = `00${ch}`;
          break;
        case 4:
          break;
        case 5:
          ch = `000${ch}`;
          break;
        default:
          throw new Error("unrecognized option");
      }
      return ch;
    };
    exports.charsToDec = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToDec: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        ret += chars[bounds.beg];
        for (let i = bounds.beg + 1; i < bounds.end; i += 1) {
          ret += `,${chars[i]}`;
        }
      }
      return ret;
    };
    exports.charsToHex = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        ret += `\\x${exports.charToHex(chars[bounds.beg])}`;
        for (let i = bounds.beg + 1; i < bounds.end; i += 1) {
          ret += `,\\x${exports.charToHex(chars[i])}`;
        }
      }
      return ret;
    };
    exports.charsToHtmlEntities = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        for (let i = bounds.beg; i < bounds.end; i += 1) {
          ret += `&#x${chars[i].toString(16)};`;
        }
      }
      return ret;
    };
    function isUnicode(char) {
      if (char >= 55296 && char <= 57343) {
        return false;
      }
      if (char > 1114111) {
        return false;
      }
      return true;
    }
    exports.charsToUnicode = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToUnicode: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        for (let i = bounds.beg; i < bounds.end; i += 1) {
          if (isUnicode(chars[i])) {
            ret += `&#${chars[i]};`;
          } else {
            ret += ` U+${exports.charToHex(chars[i])}`;
          }
        }
      }
      return ret;
    };
    exports.charsToJsUnicode = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToJsUnicode: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        ret += `\\u${exports.charToHex(chars[bounds.beg])}`;
        for (let i = bounds.beg + 1; i < bounds.end; i += 1) {
          ret += `,\\u${exports.charToHex(chars[i])}`;
        }
      }
      return ret;
    };
    exports.charsToAscii = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToAscii: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      for (let i = bounds.beg; i < bounds.end; i += 1) {
        const char = chars[i];
        if (char >= 32 && char <= 126) {
          ret += String.fromCharCode(char);
        } else {
          ret += `\\x${exports.charToHex(char)}`;
        }
      }
      return ret;
    };
    exports.charsToAsciiHtml = function(chars, beg, len) {
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToAsciiHtml: input must be an array of integers`);
      }
      let html = "";
      let char;
      const bounds = getBounds(chars.length, beg, len);
      for (let i = bounds.beg; i < bounds.end; i += 1) {
        char = chars[i];
        if (char < 32 || char === 127) {
          html += `<span class="${style.CLASS_CTRLCHAR}">${exports.asciiChars[char]}</span>`;
        } else if (char > 127) {
          html += `<span class="${style.CLASS_CTRLCHAR}">U+${exports.charToHex(char)}</span>`;
        } else {
          html += exports.asciiChars[char];
        }
      }
      return html;
    };
    exports.stringToAsciiHtml = function(str) {
      const chars = converter.decode("STRING", str);
      return this.charsToAsciiHtml(chars);
    };
  }
});

// node_modules/apg-js/src/apg-lib/ast.js
var require_ast = __commonJS({
  "node_modules/apg-js/src/apg-lib/ast.js"(exports, module) {
    module.exports = function exportsAst() {
      const id = require_identifiers();
      const utils = require_utilities();
      const thisFileName = "ast.js: ";
      const that = this;
      let rules = null;
      let udts = null;
      let chars = null;
      let nodeCount = 0;
      const nodesDefined = [];
      const nodeCallbacks = [];
      const stack = [];
      const records = [];
      this.callbacks = [];
      this.astObject = "astObject";
      this.init = function init(rulesIn, udtsIn, charsIn) {
        stack.length = 0;
        records.length = 0;
        nodesDefined.length = 0;
        nodeCount = 0;
        rules = rulesIn;
        udts = udtsIn;
        chars = charsIn;
        let i;
        const list = [];
        for (i = 0; i < rules.length; i += 1) {
          list.push(rules[i].lower);
        }
        for (i = 0; i < udts.length; i += 1) {
          list.push(udts[i].lower);
        }
        nodeCount = rules.length + udts.length;
        for (i = 0; i < nodeCount; i += 1) {
          nodesDefined[i] = false;
          nodeCallbacks[i] = null;
        }
        for (const index in that.callbacks) {
          const lower = index.toLowerCase();
          i = list.indexOf(lower);
          if (i < 0) {
            throw new Error(`${thisFileName}init: node '${index}' not a rule or udt name`);
          }
          if (typeof that.callbacks[index] === "function") {
            nodesDefined[i] = true;
            nodeCallbacks[i] = that.callbacks[index];
          }
          if (that.callbacks[index] === true) {
            nodesDefined[i] = true;
          }
        }
      };
      this.ruleDefined = function ruleDefined(index) {
        return nodesDefined[index] !== false;
      };
      this.udtDefined = function udtDefined(index) {
        return nodesDefined[rules.length + index] !== false;
      };
      this.down = function down(callbackIndex, name) {
        const thisIndex = records.length;
        stack.push(thisIndex);
        records.push({
          name,
          thisIndex,
          thatIndex: null,
          state: id.SEM_PRE,
          callbackIndex,
          phraseIndex: null,
          phraseLength: null,
          stack: stack.length
        });
        return thisIndex;
      };
      this.up = function up(callbackIndex, name, phraseIndex, phraseLength) {
        const thisIndex = records.length;
        const thatIndex = stack.pop();
        records.push({
          name,
          thisIndex,
          thatIndex,
          state: id.SEM_POST,
          callbackIndex,
          phraseIndex,
          phraseLength,
          stack: stack.length
        });
        records[thatIndex].thatIndex = thisIndex;
        records[thatIndex].phraseIndex = phraseIndex;
        records[thatIndex].phraseLength = phraseLength;
        return thisIndex;
      };
      this.translate = function translate(data) {
        let ret;
        let callback;
        let record;
        for (let i = 0; i < records.length; i += 1) {
          record = records[i];
          callback = nodeCallbacks[record.callbackIndex];
          if (record.state === id.SEM_PRE) {
            if (callback !== null) {
              ret = callback(id.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);
              if (ret === id.SEM_SKIP) {
                i = record.thatIndex;
              }
            }
          } else if (callback !== null) {
            callback(id.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);
          }
        }
      };
      this.setLength = function setLength(length) {
        records.length = length;
        if (length > 0) {
          stack.length = records[length - 1].stack;
        } else {
          stack.length = 0;
        }
      };
      this.getLength = function getLength() {
        return records.length;
      };
      function indent(n) {
        let ret = "";
        for (let i = 0; i < n; i += 1) {
          ret += " ";
        }
        return ret;
      }
      this.toXml = function toSml(modeArg) {
        let display = utils.charsToDec;
        let caption = "decimal integer character codes";
        if (typeof modeArg === "string" && modeArg.length >= 3) {
          const mode = modeArg.slice(0, 3).toLowerCase();
          if (mode === "asc") {
            display = utils.charsToAscii;
            caption = "ASCII for printing characters, hex for non-printing";
          } else if (mode === "hex") {
            display = utils.charsToHex;
            caption = "hexadecimal integer character codes";
          } else if (mode === "uni") {
            display = utils.charsToUnicode;
            caption = "Unicode UTF-32 integer character codes";
          }
        }
        let xml = "";
        let depth = 0;
        xml += '<?xml version="1.0" encoding="utf-8"?>\n';
        xml += `<root nodes="${records.length / 2}" characters="${chars.length}">
`;
        xml += `<!-- input string, ${caption} -->
`;
        xml += indent(depth + 2);
        xml += display(chars);
        xml += "\n";
        records.forEach((rec) => {
          if (rec.state === id.SEM_PRE) {
            depth += 1;
            xml += indent(depth);
            xml += `<node name="${rec.name}" index="${rec.phraseIndex}" length="${rec.phraseLength}">
`;
            xml += indent(depth + 2);
            xml += display(chars, rec.phraseIndex, rec.phraseLength);
            xml += "\n";
          } else {
            xml += indent(depth);
            xml += `</node><!-- name="${rec.name}" -->
`;
            depth -= 1;
          }
        });
        xml += "</root>\n";
        return xml;
      };
      this.phrases = function phrases() {
        const obj = {};
        let i;
        let record;
        for (i = 0; i < records.length; i += 1) {
          record = records[i];
          if (record.state === id.SEM_PRE) {
            if (!Array.isArray(obj[record.name])) {
              obj[record.name] = [];
            }
            obj[record.name].push({
              index: record.phraseIndex,
              length: record.phraseLength
            });
          }
        }
        return obj;
      };
    };
  }
});

// node_modules/apg-js/src/apg-lib/circular-buffer.js
var require_circular_buffer = __commonJS({
  "node_modules/apg-js/src/apg-lib/circular-buffer.js"(exports, module) {
    module.exports = function exportsCircularBuffer() {
      "use strict;";
      const thisFileName = "circular-buffer.js: ";
      let itemIndex = -1;
      let maxListSize = 0;
      this.init = function init(size) {
        if (typeof size !== "number" || size <= 0) {
          throw new Error(`${thisFileName}init: circular buffer size must an integer > 0`);
        }
        maxListSize = Math.ceil(size);
        itemIndex = -1;
      };
      this.increment = function increment() {
        itemIndex += 1;
        return (itemIndex + maxListSize) % maxListSize;
      };
      this.maxSize = function maxSize() {
        return maxListSize;
      };
      this.items = function items() {
        return itemIndex + 1;
      };
      this.getListIndex = function getListIndex(item) {
        if (itemIndex === -1) {
          return -1;
        }
        if (item < 0 || item > itemIndex) {
          return -1;
        }
        if (itemIndex - item >= maxListSize) {
          return -1;
        }
        return (item + maxListSize) % maxListSize;
      };
      this.forEach = function forEach(fn) {
        if (itemIndex === -1) {
          return;
        }
        if (itemIndex < maxListSize) {
          for (let i = 0; i <= itemIndex; i += 1) {
            fn(i, i);
          }
          return;
        }
        for (let i = itemIndex - maxListSize + 1; i <= itemIndex; i += 1) {
          const listIndex = (i + maxListSize) % maxListSize;
          fn(listIndex, i);
        }
      };
    };
  }
});

// node_modules/apg-js/src/apg-lib/parser.js
var require_parser = __commonJS({
  "node_modules/apg-js/src/apg-lib/parser.js"(exports, module) {
    module.exports = function parser() {
      const id = require_identifiers();
      const utils = require_utilities();
      const thisFileName = "parser.js: ";
      const thisThis = this;
      let opExecute;
      this.ast = null;
      this.stats = null;
      this.trace = null;
      this.callbacks = [];
      let opcodes = null;
      let chars = null;
      let charsBegin;
      let charsLength;
      let charsEnd;
      let lookAround;
      let treeDepth = 0;
      let maxTreeDepth = 0;
      let nodeHits = 0;
      let ruleCallbacks = null;
      let udtCallbacks = null;
      let rules = null;
      let udts = null;
      let syntaxData = null;
      let maxMatched = 0;
      let limitTreeDepth = Infinity;
      let limitNodeHits = Infinity;
      const evaluateRule = function evaluateRule2(ruleIndex, phraseIndex, sysData) {
        const functionName = `${thisFileName}evaluateRule(): `;
        if (ruleIndex >= rules.length) {
          throw new Error(`${functionName}rule index: ${ruleIndex} out of range`);
        }
        if (phraseIndex >= charsEnd) {
          throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);
        }
        const { length } = opcodes;
        opcodes.push({
          type: id.RNM,
          index: ruleIndex
        });
        opExecute(length, phraseIndex, sysData);
        opcodes.pop();
      };
      const evaluateUdt = function(udtIndex, phraseIndex, sysData) {
        const functionName = `${thisFileName}evaluateUdt(): `;
        if (udtIndex >= udts.length) {
          throw new Error(`${functionName}udt index: ${udtIndex} out of range`);
        }
        if (phraseIndex >= charsEnd) {
          throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);
        }
        const { length } = opcodes;
        opcodes.push({
          type: id.UDT,
          empty: udts[udtIndex].empty,
          index: udtIndex
        });
        opExecute(length, phraseIndex, sysData);
        opcodes.pop();
      };
      const clear = function() {
        treeDepth = 0;
        maxTreeDepth = 0;
        nodeHits = 0;
        maxMatched = 0;
        lookAround = [
          {
            lookAround: id.LOOKAROUND_NONE,
            anchor: 0,
            charsEnd: 0,
            charsLength: 0
          }
        ];
        rules = null;
        udts = null;
        chars = null;
        charsBegin = 0;
        charsLength = 0;
        charsEnd = 0;
        ruleCallbacks = null;
        udtCallbacks = null;
        syntaxData = null;
        opcodes = null;
      };
      const backRef = function() {
        const stack = [];
        const init = function() {
          const obj = {};
          rules.forEach((rule) => {
            if (rule.isBkr) {
              obj[rule.lower] = null;
            }
          });
          if (udts.length > 0) {
            udts.forEach((udt) => {
              if (udt.isBkr) {
                obj[udt.lower] = null;
              }
            });
          }
          stack.push(obj);
        };
        const copy = function() {
          const top = stack[stack.length - 1];
          const obj = {};
          for (const name in top) {
            obj[name] = top[name];
          }
          return obj;
        };
        this.push = function push() {
          stack.push(copy());
        };
        this.pop = function pop(lengthArg) {
          let length = lengthArg;
          if (!length) {
            length = stack.length - 1;
          }
          if (length < 1 || length > stack.length) {
            throw new Error(`${thisFileName}backRef.pop(): bad length: ${length}`);
          }
          stack.length = length;
          return stack[stack.length - 1];
        };
        this.length = function length() {
          return stack.length;
        };
        this.savePhrase = function savePhrase(name, index, length) {
          stack[stack.length - 1][name] = {
            phraseIndex: index,
            phraseLength: length
          };
        };
        this.getPhrase = function(name) {
          return stack[stack.length - 1][name];
        };
        init();
      };
      const systemData = function systemData2() {
        const thisData = this;
        this.state = id.ACTIVE;
        this.phraseLength = 0;
        this.ruleIndex = 0;
        this.udtIndex = 0;
        this.lookAround = lookAround[lookAround.length - 1];
        this.uFrame = new backRef();
        this.pFrame = new backRef();
        this.evaluateRule = evaluateRule;
        this.evaluateUdt = evaluateUdt;
        this.refresh = function refresh() {
          thisData.state = id.ACTIVE;
          thisData.phraseLength = 0;
          thisData.lookAround = lookAround[lookAround.length - 1];
        };
      };
      const lookAroundValue = function lookAroundValue2() {
        return lookAround[lookAround.length - 1];
      };
      const inLookAround = function inLookAround2() {
        return lookAround.length > 1;
      };
      const inLookBehind = function() {
        return lookAround[lookAround.length - 1].lookAround === id.LOOKAROUND_BEHIND;
      };
      const initializeAst = function() {
        const functionName = `${thisFileName}initializeAst(): `;
        const TRUE = true;
        while (TRUE) {
          if (thisThis.ast === void 0) {
            thisThis.ast = null;
            break;
          }
          if (thisThis.ast === null) {
            break;
          }
          if (thisThis.ast.astObject !== "astObject") {
            throw new Error(`${functionName}ast object not recognized`);
          }
          break;
        }
        if (thisThis.ast !== null) {
          thisThis.ast.init(rules, udts, chars);
        }
      };
      const initializeTrace = function() {
        const functionName = `${thisFileName}initializeTrace(): `;
        const TRUE = true;
        while (TRUE) {
          if (thisThis.trace === void 0) {
            thisThis.trace = null;
            break;
          }
          if (thisThis.trace === null) {
            break;
          }
          if (thisThis.trace.traceObject !== "traceObject") {
            throw new Error(`${functionName}trace object not recognized`);
          }
          break;
        }
        if (thisThis.trace !== null) {
          thisThis.trace.init(rules, udts, chars);
        }
      };
      const initializeStats = function() {
        const functionName = `${thisFileName}initializeStats(): `;
        const TRUE = true;
        while (TRUE) {
          if (thisThis.stats === void 0) {
            thisThis.stats = null;
            break;
          }
          if (thisThis.stats === null) {
            break;
          }
          if (thisThis.stats.statsObject !== "statsObject") {
            throw new Error(`${functionName}stats object not recognized`);
          }
          break;
        }
        if (thisThis.stats !== null) {
          thisThis.stats.init(rules, udts);
        }
      };
      const initializeGrammar = function(grammar) {
        const functionName = `${thisFileName}initializeGrammar(): `;
        if (!grammar) {
          throw new Error(`${functionName}grammar object undefined`);
        }
        if (grammar.grammarObject !== "grammarObject") {
          throw new Error(`${functionName}bad grammar object`);
        }
        rules = grammar.rules;
        udts = grammar.udts;
      };
      const initializeStartRule = function(startRule) {
        const functionName = `${thisFileName}initializeStartRule(): `;
        let start = null;
        if (typeof startRule === "number") {
          if (startRule >= rules.length) {
            throw new Error(`${functionName}start rule index too large: max: ${rules.length}: index: ${startRule}`);
          }
          start = startRule;
        } else if (typeof startRule === "string") {
          const lower = startRule.toLowerCase();
          for (let i = 0; i < rules.length; i += 1) {
            if (lower === rules[i].lower) {
              start = rules[i].index;
              break;
            }
          }
          if (start === null) {
            throw new Error(`${functionName}start rule name '${startRule}' not recognized`);
          }
        } else {
          throw new Error(`${functionName}type of start rule '${typeof startRule}' not recognized`);
        }
        return start;
      };
      const initializeInputChars = function initializeInputChars2(inputArg, begArg, lenArg) {
        const functionName = `${thisFileName}initializeInputChars(): `;
        let input = inputArg;
        let beg = begArg;
        let len = lenArg;
        if (input === void 0) {
          throw new Error(`${functionName}input string is undefined`);
        }
        if (input === null) {
          throw new Error(`${functionName}input string is null`);
        }
        if (typeof input === "string") {
          input = utils.stringToChars(input);
        } else if (!Array.isArray(input)) {
          throw new Error(`${functionName}input string is not a string or array`);
        }
        if (input.length > 0) {
          if (typeof input[0] !== "number") {
            throw new Error(`${functionName}input string not an array of integers`);
          }
        }
        if (typeof beg !== "number") {
          beg = 0;
        } else {
          beg = Math.floor(beg);
          if (beg < 0 || beg > input.length) {
            throw new Error(`${functionName}input beginning index out of range: ${beg}`);
          }
        }
        if (typeof len !== "number") {
          len = input.length - beg;
        } else {
          len = Math.floor(len);
          if (len < 0 || len > input.length - beg) {
            throw new Error(`${functionName}input length out of range: ${len}`);
          }
        }
        chars = input;
        charsBegin = beg;
        charsLength = len;
        charsEnd = charsBegin + charsLength;
      };
      const initializeCallbacks = function() {
        const functionName = `${thisFileName}initializeCallbacks(): `;
        let i;
        ruleCallbacks = [];
        udtCallbacks = [];
        for (i = 0; i < rules.length; i += 1) {
          ruleCallbacks[i] = null;
        }
        for (i = 0; i < udts.length; i += 1) {
          udtCallbacks[i] = null;
        }
        let func;
        const list = [];
        for (i = 0; i < rules.length; i += 1) {
          list.push(rules[i].lower);
        }
        for (i = 0; i < udts.length; i += 1) {
          list.push(udts[i].lower);
        }
        for (const index in thisThis.callbacks) {
          i = list.indexOf(index.toLowerCase());
          if (i < 0) {
            throw new Error(`${functionName}syntax callback '${index}' not a rule or udt name`);
          }
          func = thisThis.callbacks[index];
          if (!func) {
            func = null;
          }
          if (typeof func === "function" || func === null) {
            if (i < rules.length) {
              ruleCallbacks[i] = func;
            } else {
              udtCallbacks[i - rules.length] = func;
            }
          } else {
            throw new Error(
              `${functionName}syntax callback[${index}] must be function reference or 'false' (false/null/undefined/etc.)`
            );
          }
        }
        for (i = 0; i < udts.length; i += 1) {
          if (udtCallbacks[i] === null) {
            throw new Error(
              `${functionName}all UDT callbacks must be defined. UDT callback[${udts[i].lower}] not a function reference`
            );
          }
        }
      };
      this.setMaxTreeDepth = function(depth) {
        if (typeof depth !== "number") {
          throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);
        }
        limitTreeDepth = Math.floor(depth);
        if (limitTreeDepth <= 0) {
          throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);
        }
      };
      this.setMaxNodeHits = function(hits) {
        if (typeof hits !== "number") {
          throw new Error(`parser: max node hits must be integer > 0: ${hits}`);
        }
        limitNodeHits = Math.floor(hits);
        if (limitNodeHits <= 0) {
          throw new Error(`parser: max node hits must be integer > 0: ${hits}`);
        }
      };
      const privateParse = function(grammar, startRuleArg, callbackData) {
        let success;
        const functionName = `${thisFileName}parse(): `;
        initializeGrammar(grammar);
        const startRule = initializeStartRule(startRuleArg);
        initializeCallbacks();
        initializeTrace();
        initializeStats();
        initializeAst();
        const sysData = new systemData();
        if (!(callbackData === void 0 || callbackData === null)) {
          syntaxData = callbackData;
        }
        opcodes = [
          {
            type: id.RNM,
            index: startRule
          }
        ];
        opExecute(0, charsBegin, sysData);
        opcodes = null;
        switch (sysData.state) {
          case id.ACTIVE:
            throw new Error(`${functionName}final state should never be 'ACTIVE'`);
          case id.NOMATCH:
            success = false;
            break;
          case id.EMPTY:
          case id.MATCH:
            if (sysData.phraseLength === charsLength) {
              success = true;
            } else {
              success = false;
            }
            break;
          default:
            throw new Error("unrecognized state");
        }
        return {
          success,
          state: sysData.state,
          length: charsLength,
          matched: sysData.phraseLength,
          maxMatched,
          maxTreeDepth,
          nodeHits,
          inputLength: chars.length,
          subBegin: charsBegin,
          subEnd: charsEnd,
          subLength: charsLength
        };
      };
      this.parseSubstring = function parseSubstring(grammar, startRule, inputChars, inputIndex, inputLength, callbackData) {
        clear();
        initializeInputChars(inputChars, inputIndex, inputLength);
        return privateParse(grammar, startRule, callbackData);
      };
      this.parse = function parse(grammar, startRule, inputChars, callbackData) {
        clear();
        initializeInputChars(inputChars, 0, inputChars.length);
        return privateParse(grammar, startRule, callbackData);
      };
      const opALT = function(opIndex, phraseIndex, sysData) {
        const op = opcodes[opIndex];
        for (let i = 0; i < op.children.length; i += 1) {
          opExecute(op.children[i], phraseIndex, sysData);
          if (sysData.state !== id.NOMATCH) {
            break;
          }
        }
      };
      const opCAT = function(opIndex, phraseIndex, sysData) {
        let success;
        let astLength;
        let catCharIndex;
        let catPhrase;
        const op = opcodes[opIndex];
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        success = true;
        catCharIndex = phraseIndex;
        catPhrase = 0;
        for (let i = 0; i < op.children.length; i += 1) {
          opExecute(op.children[i], catCharIndex, sysData);
          if (sysData.state === id.NOMATCH) {
            success = false;
            break;
          } else {
            catCharIndex += sysData.phraseLength;
            catPhrase += sysData.phraseLength;
          }
        }
        if (success) {
          sysData.state = catPhrase === 0 ? id.EMPTY : id.MATCH;
          sysData.phraseLength = catPhrase;
        } else {
          sysData.state = id.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      };
      const opREP = function(opIndex, phraseIndex, sysData) {
        let astLength;
        let repCharIndex;
        let repPhrase;
        let repCount;
        const op = opcodes[opIndex];
        if (op.max === 0) {
          sysData.state = id.EMPTY;
          sysData.phraseLength = 0;
          return;
        }
        repCharIndex = phraseIndex;
        repPhrase = 0;
        repCount = 0;
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        const TRUE = true;
        while (TRUE) {
          if (repCharIndex >= charsEnd) {
            break;
          }
          opExecute(opIndex + 1, repCharIndex, sysData);
          if (sysData.state === id.NOMATCH) {
            break;
          }
          if (sysData.state === id.EMPTY) {
            break;
          }
          repCount += 1;
          repPhrase += sysData.phraseLength;
          repCharIndex += sysData.phraseLength;
          if (repCount === op.max) {
            break;
          }
        }
        if (sysData.state === id.EMPTY) {
          sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;
          sysData.phraseLength = repPhrase;
        } else if (repCount >= op.min) {
          sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;
          sysData.phraseLength = repPhrase;
        } else {
          sysData.state = id.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      };
      const validateRnmCallbackResult = function(rule, sysData, charsLeft, down) {
        if (sysData.phraseLength > charsLeft) {
          let str = `${thisFileName}opRNM(${rule.name}): callback function error: `;
          str += `sysData.phraseLength: ${sysData.phraseLength}`;
          str += ` must be <= remaining chars: ${charsLeft}`;
          throw new Error(str);
        }
        switch (sysData.state) {
          case id.ACTIVE:
            if (down !== true) {
              throw new Error(
                `${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`
              );
            }
            break;
          case id.EMPTY:
            sysData.phraseLength = 0;
            break;
          case id.MATCH:
            if (sysData.phraseLength === 0) {
              sysData.state = id.EMPTY;
            }
            break;
          case id.NOMATCH:
            sysData.phraseLength = 0;
            break;
          default:
            throw new Error(
              `${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData.state}`
            );
        }
      };
      const opRNM = function(opIndex, phraseIndex, sysData) {
        let astLength;
        let astDefined;
        let savedOpcodes;
        let ulen;
        let plen;
        let saveFrame;
        const op = opcodes[opIndex];
        const rule = rules[op.index];
        const callback = ruleCallbacks[rule.index];
        const notLookAround = !inLookAround();
        if (notLookAround) {
          astDefined = thisThis.ast && thisThis.ast.ruleDefined(op.index);
          if (astDefined) {
            astLength = thisThis.ast.getLength();
            thisThis.ast.down(op.index, rules[op.index].name);
          }
          ulen = sysData.uFrame.length();
          plen = sysData.pFrame.length();
          sysData.uFrame.push();
          sysData.pFrame.push();
          saveFrame = sysData.pFrame;
          sysData.pFrame = new backRef();
        }
        if (callback === null) {
          savedOpcodes = opcodes;
          opcodes = rule.opcodes;
          opExecute(0, phraseIndex, sysData);
          opcodes = savedOpcodes;
        } else {
          const charsLeft = charsEnd - phraseIndex;
          sysData.ruleIndex = rule.index;
          callback(sysData, chars, phraseIndex, syntaxData);
          validateRnmCallbackResult(rule, sysData, charsLeft, true);
          if (sysData.state === id.ACTIVE) {
            savedOpcodes = opcodes;
            opcodes = rule.opcodes;
            opExecute(0, phraseIndex, sysData);
            opcodes = savedOpcodes;
            sysData.ruleIndex = rule.index;
            callback(sysData, chars, phraseIndex, syntaxData);
            validateRnmCallbackResult(rule, sysData, charsLeft, false);
          }
        }
        if (notLookAround) {
          if (astDefined) {
            if (sysData.state === id.NOMATCH) {
              thisThis.ast.setLength(astLength);
            } else {
              thisThis.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);
            }
          }
          sysData.pFrame = saveFrame;
          if (sysData.state === id.NOMATCH) {
            sysData.uFrame.pop(ulen);
            sysData.pFrame.pop(plen);
          } else if (rule.isBkr) {
            sysData.pFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);
            sysData.uFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);
          }
        }
      };
      const validateUdtCallbackResult = function(udt, sysData, charsLeft) {
        if (sysData.phraseLength > charsLeft) {
          let str = `${thisFileName}opUDT(${udt.name}): callback function error: `;
          str += `sysData.phraseLength: ${sysData.phraseLength}`;
          str += ` must be <= remaining chars: ${charsLeft}`;
          throw new Error(str);
        }
        switch (sysData.state) {
          case id.ACTIVE:
            throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. ACTIVE state not allowed.`);
          case id.EMPTY:
            if (udt.empty === false) {
              throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);
            } else {
              sysData.phraseLength = 0;
            }
            break;
          case id.MATCH:
            if (sysData.phraseLength === 0) {
              if (udt.empty === false) {
                throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);
              } else {
                sysData.state = id.EMPTY;
              }
            }
            break;
          case id.NOMATCH:
            sysData.phraseLength = 0;
            break;
          default:
            throw new Error(
              `${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData.state}`
            );
        }
      };
      const opUDT = function(opIndex, phraseIndex, sysData) {
        let astLength;
        let astIndex;
        let astDefined;
        let ulen;
        let plen;
        let saveFrame;
        const op = opcodes[opIndex];
        const udt = udts[op.index];
        sysData.UdtIndex = udt.index;
        const notLookAround = !inLookAround();
        if (notLookAround) {
          astDefined = thisThis.ast && thisThis.ast.udtDefined(op.index);
          if (astDefined) {
            astIndex = rules.length + op.index;
            astLength = thisThis.ast.getLength();
            thisThis.ast.down(astIndex, udt.name);
          }
          ulen = sysData.uFrame.length();
          plen = sysData.pFrame.length();
          sysData.uFrame.push();
          sysData.pFrame.push();
          saveFrame = sysData.pFrame;
          sysData.pFrame = new backRef();
        }
        const charsLeft = charsEnd - phraseIndex;
        udtCallbacks[op.index](sysData, chars, phraseIndex, syntaxData);
        validateUdtCallbackResult(udt, sysData, charsLeft);
        if (notLookAround) {
          if (astDefined) {
            if (sysData.state === id.NOMATCH) {
              thisThis.ast.setLength(astLength);
            } else {
              thisThis.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);
            }
          }
          sysData.pFrame = saveFrame;
          if (sysData.state === id.NOMATCH) {
            sysData.uFrame.pop(ulen);
            sysData.pFrame.pop(plen);
          } else if (udt.isBkr) {
            sysData.pFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);
            sysData.uFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);
          }
        }
      };
      const opAND = function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id.LOOKAROUND_AHEAD,
          anchor: phraseIndex,
          charsEnd,
          charsLength
        });
        charsEnd = chars.length;
        charsLength = chars.length - charsBegin;
        opExecute(opIndex + 1, phraseIndex, sysData);
        const pop = lookAround.pop();
        charsEnd = pop.charsEnd;
        charsLength = pop.charsLength;
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id.EMPTY:
            sysData.state = id.EMPTY;
            break;
          case id.MATCH:
            sysData.state = id.EMPTY;
            break;
          case id.NOMATCH:
            sysData.state = id.NOMATCH;
            break;
          default:
            throw new Error(`opAND: invalid state ${sysData.state}`);
        }
      };
      const opNOT = function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id.LOOKAROUND_AHEAD,
          anchor: phraseIndex,
          charsEnd,
          charsLength
        });
        charsEnd = chars.length;
        charsLength = chars.length - charsBegin;
        opExecute(opIndex + 1, phraseIndex, sysData);
        const pop = lookAround.pop();
        charsEnd = pop.charsEnd;
        charsLength = pop.charsLength;
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id.EMPTY:
          case id.MATCH:
            sysData.state = id.NOMATCH;
            break;
          case id.NOMATCH:
            sysData.state = id.EMPTY;
            break;
          default:
            throw new Error(`opNOT: invalid state ${sysData.state}`);
        }
      };
      const opTRG = function(opIndex, phraseIndex, sysData) {
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        if (phraseIndex < charsEnd) {
          if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {
            sysData.state = id.MATCH;
            sysData.phraseLength = 1;
          }
        }
      };
      const opTBS = function(opIndex, phraseIndex, sysData) {
        let i;
        const op = opcodes[opIndex];
        const len = op.string.length;
        sysData.state = id.NOMATCH;
        if (phraseIndex + len <= charsEnd) {
          for (i = 0; i < len; i += 1) {
            if (chars[phraseIndex + i] !== op.string[i]) {
              return;
            }
          }
          sysData.state = id.MATCH;
          sysData.phraseLength = len;
        }
      };
      const opTLS = function(opIndex, phraseIndex, sysData) {
        let i;
        let code;
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        const len = op.string.length;
        if (len === 0) {
          sysData.state = id.EMPTY;
          return;
        }
        if (phraseIndex + len <= charsEnd) {
          for (i = 0; i < len; i += 1) {
            code = chars[phraseIndex + i];
            if (code >= 65 && code <= 90) {
              code += 32;
            }
            if (code !== op.string[i]) {
              return;
            }
          }
          sysData.state = id.MATCH;
          sysData.phraseLength = len;
        }
      };
      const opABG = function(opIndex, phraseIndex, sysData) {
        sysData.state = id.NOMATCH;
        sysData.phraseLength = 0;
        sysData.state = phraseIndex === 0 ? id.EMPTY : id.NOMATCH;
      };
      const opAEN = function(opIndex, phraseIndex, sysData) {
        sysData.state = id.NOMATCH;
        sysData.phraseLength = 0;
        sysData.state = phraseIndex === chars.length ? id.EMPTY : id.NOMATCH;
      };
      const opBKR = function(opIndex, phraseIndex, sysData) {
        let i;
        let code;
        let lmcode;
        let lower;
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        if (op.index < rules.length) {
          lower = rules[op.index].lower;
        } else {
          lower = udts[op.index - rules.length].lower;
        }
        const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);
        const insensitive = op.bkrCase === id.BKR_MODE_CI;
        if (frame === null) {
          return;
        }
        const lmIndex = frame.phraseIndex;
        const len = frame.phraseLength;
        if (len === 0) {
          sysData.state = id.EMPTY;
          return;
        }
        if (phraseIndex + len <= charsEnd) {
          if (insensitive) {
            for (i = 0; i < len; i += 1) {
              code = chars[phraseIndex + i];
              lmcode = chars[lmIndex + i];
              if (code >= 65 && code <= 90) {
                code += 32;
              }
              if (lmcode >= 65 && lmcode <= 90) {
                lmcode += 32;
              }
              if (code !== lmcode) {
                return;
              }
            }
            sysData.state = id.MATCH;
            sysData.phraseLength = len;
          } else {
            for (i = 0; i < len; i += 1) {
              code = chars[phraseIndex + i];
              lmcode = chars[lmIndex + i];
              if (code !== lmcode) {
                return;
              }
            }
          }
          sysData.state = id.MATCH;
          sysData.phraseLength = len;
        }
      };
      const opBKA = function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id.LOOKAROUND_BEHIND,
          anchor: phraseIndex
        });
        opExecute(opIndex + 1, phraseIndex, sysData);
        lookAround.pop();
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id.EMPTY:
            sysData.state = id.EMPTY;
            break;
          case id.MATCH:
            sysData.state = id.EMPTY;
            break;
          case id.NOMATCH:
            sysData.state = id.NOMATCH;
            break;
          default:
            throw new Error(`opBKA: invalid state ${sysData.state}`);
        }
      };
      const opBKN = function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id.LOOKAROUND_BEHIND,
          anchor: phraseIndex
        });
        opExecute(opIndex + 1, phraseIndex, sysData);
        lookAround.pop();
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id.EMPTY:
          case id.MATCH:
            sysData.state = id.NOMATCH;
            break;
          case id.NOMATCH:
            sysData.state = id.EMPTY;
            break;
          default:
            throw new Error(`opBKN: invalid state ${sysData.state}`);
        }
      };
      const opCATBehind = function(opIndex, phraseIndex, sysData) {
        let success;
        let astLength;
        let catCharIndex;
        let catMatched;
        const op = opcodes[opIndex];
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        success = true;
        catCharIndex = phraseIndex;
        catMatched = 0;
        for (let i = op.children.length - 1; i >= 0; i -= 1) {
          opExecute(op.children[i], catCharIndex, sysData);
          catCharIndex -= sysData.phraseLength;
          catMatched += sysData.phraseLength;
          if (sysData.state === id.NOMATCH) {
            success = false;
            break;
          }
        }
        if (success) {
          sysData.state = catMatched === 0 ? id.EMPTY : id.MATCH;
          sysData.phraseLength = catMatched;
        } else {
          sysData.state = id.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      };
      const opREPBehind = function(opIndex, phraseIndex, sysData) {
        let astLength;
        let repCharIndex;
        let repPhrase;
        let repCount;
        const op = opcodes[opIndex];
        repCharIndex = phraseIndex;
        repPhrase = 0;
        repCount = 0;
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        const TRUE = true;
        while (TRUE) {
          if (repCharIndex <= 0) {
            break;
          }
          opExecute(opIndex + 1, repCharIndex, sysData);
          if (sysData.state === id.NOMATCH) {
            break;
          }
          if (sysData.state === id.EMPTY) {
            break;
          }
          repCount += 1;
          repPhrase += sysData.phraseLength;
          repCharIndex -= sysData.phraseLength;
          if (repCount === op.max) {
            break;
          }
        }
        if (sysData.state === id.EMPTY) {
          sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;
          sysData.phraseLength = repPhrase;
        } else if (repCount >= op.min) {
          sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;
          sysData.phraseLength = repPhrase;
        } else {
          sysData.state = id.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      };
      const opTRGBehind = function(opIndex, phraseIndex, sysData) {
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        sysData.phraseLength = 0;
        if (phraseIndex > 0) {
          const char = chars[phraseIndex - 1];
          if (op.min <= char && char <= op.max) {
            sysData.state = id.MATCH;
            sysData.phraseLength = 1;
          }
        }
      };
      const opTBSBehind = function(opIndex, phraseIndex, sysData) {
        let i;
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        const len = op.string.length;
        const beg = phraseIndex - len;
        if (beg >= 0) {
          for (i = 0; i < len; i += 1) {
            if (chars[beg + i] !== op.string[i]) {
              return;
            }
          }
          sysData.state = id.MATCH;
          sysData.phraseLength = len;
        }
      };
      const opTLSBehind = function(opIndex, phraseIndex, sysData) {
        let char;
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        const len = op.string.length;
        if (len === 0) {
          sysData.state = id.EMPTY;
          return;
        }
        const beg = phraseIndex - len;
        if (beg >= 0) {
          for (let i = 0; i < len; i += 1) {
            char = chars[beg + i];
            if (char >= 65 && char <= 90) {
              char += 32;
            }
            if (char !== op.string[i]) {
              return;
            }
          }
          sysData.state = id.MATCH;
          sysData.phraseLength = len;
        }
      };
      const opBKRBehind = function(opIndex, phraseIndex, sysData) {
        let i;
        let code;
        let lmcode;
        let lower;
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        sysData.phraseLength = 0;
        if (op.index < rules.length) {
          lower = rules[op.index].lower;
        } else {
          lower = udts[op.index - rules.length].lower;
        }
        const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);
        const insensitive = op.bkrCase === id.BKR_MODE_CI;
        if (frame === null) {
          return;
        }
        const lmIndex = frame.phraseIndex;
        const len = frame.phraseLength;
        if (len === 0) {
          sysData.state = id.EMPTY;
          sysData.phraseLength = 0;
          return;
        }
        const beg = phraseIndex - len;
        if (beg >= 0) {
          if (insensitive) {
            for (i = 0; i < len; i += 1) {
              code = chars[beg + i];
              lmcode = chars[lmIndex + i];
              if (code >= 65 && code <= 90) {
                code += 32;
              }
              if (lmcode >= 65 && lmcode <= 90) {
                lmcode += 32;
              }
              if (code !== lmcode) {
                return;
              }
            }
            sysData.state = id.MATCH;
            sysData.phraseLength = len;
          } else {
            for (i = 0; i < len; i += 1) {
              code = chars[beg + i];
              lmcode = chars[lmIndex + i];
              if (code !== lmcode) {
                return;
              }
            }
          }
          sysData.state = id.MATCH;
          sysData.phraseLength = len;
        }
      };
      opExecute = function opExecuteFunc(opIndex, phraseIndex, sysData) {
        let ret = true;
        const op = opcodes[opIndex];
        nodeHits += 1;
        if (nodeHits > limitNodeHits) {
          throw new Error(`parser: maximum number of node hits exceeded: ${limitNodeHits}`);
        }
        treeDepth += 1;
        if (treeDepth > maxTreeDepth) {
          maxTreeDepth = treeDepth;
          if (maxTreeDepth > limitTreeDepth) {
            throw new Error(`parser: maximum parse tree depth exceeded: ${limitTreeDepth}`);
          }
        }
        sysData.refresh();
        if (thisThis.trace !== null) {
          const lk = lookAroundValue();
          thisThis.trace.down(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);
        }
        if (inLookBehind()) {
          switch (op.type) {
            case id.ALT:
              opALT(opIndex, phraseIndex, sysData);
              break;
            case id.CAT:
              opCATBehind(opIndex, phraseIndex, sysData);
              break;
            case id.REP:
              opREPBehind(opIndex, phraseIndex, sysData);
              break;
            case id.RNM:
              opRNM(opIndex, phraseIndex, sysData);
              break;
            case id.UDT:
              opUDT(opIndex, phraseIndex, sysData);
              break;
            case id.AND:
              opAND(opIndex, phraseIndex, sysData);
              break;
            case id.NOT:
              opNOT(opIndex, phraseIndex, sysData);
              break;
            case id.TRG:
              opTRGBehind(opIndex, phraseIndex, sysData);
              break;
            case id.TBS:
              opTBSBehind(opIndex, phraseIndex, sysData);
              break;
            case id.TLS:
              opTLSBehind(opIndex, phraseIndex, sysData);
              break;
            case id.BKR:
              opBKRBehind(opIndex, phraseIndex, sysData);
              break;
            case id.BKA:
              opBKA(opIndex, phraseIndex, sysData);
              break;
            case id.BKN:
              opBKN(opIndex, phraseIndex, sysData);
              break;
            case id.ABG:
              opABG(opIndex, phraseIndex, sysData);
              break;
            case id.AEN:
              opAEN(opIndex, phraseIndex, sysData);
              break;
            default:
              ret = false;
              break;
          }
        } else {
          switch (op.type) {
            case id.ALT:
              opALT(opIndex, phraseIndex, sysData);
              break;
            case id.CAT:
              opCAT(opIndex, phraseIndex, sysData);
              break;
            case id.REP:
              opREP(opIndex, phraseIndex, sysData);
              break;
            case id.RNM:
              opRNM(opIndex, phraseIndex, sysData);
              break;
            case id.UDT:
              opUDT(opIndex, phraseIndex, sysData);
              break;
            case id.AND:
              opAND(opIndex, phraseIndex, sysData);
              break;
            case id.NOT:
              opNOT(opIndex, phraseIndex, sysData);
              break;
            case id.TRG:
              opTRG(opIndex, phraseIndex, sysData);
              break;
            case id.TBS:
              opTBS(opIndex, phraseIndex, sysData);
              break;
            case id.TLS:
              opTLS(opIndex, phraseIndex, sysData);
              break;
            case id.BKR:
              opBKR(opIndex, phraseIndex, sysData);
              break;
            case id.BKA:
              opBKA(opIndex, phraseIndex, sysData);
              break;
            case id.BKN:
              opBKN(opIndex, phraseIndex, sysData);
              break;
            case id.ABG:
              opABG(opIndex, phraseIndex, sysData);
              break;
            case id.AEN:
              opAEN(opIndex, phraseIndex, sysData);
              break;
            default:
              ret = false;
              break;
          }
        }
        if (!inLookAround() && phraseIndex + sysData.phraseLength > maxMatched) {
          maxMatched = phraseIndex + sysData.phraseLength;
        }
        if (thisThis.stats !== null) {
          thisThis.stats.collect(op, sysData);
        }
        if (thisThis.trace !== null) {
          const lk = lookAroundValue();
          thisThis.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);
        }
        treeDepth -= 1;
        return ret;
      };
    };
  }
});

// node_modules/apg-js/src/apg-lib/stats.js
var require_stats = __commonJS({
  "node_modules/apg-js/src/apg-lib/stats.js"(exports, module) {
    module.exports = function statsFunc() {
      const id = require_identifiers();
      const utils = require_utilities();
      const style = require_style();
      const thisFileName = "stats.js: ";
      let rules = [];
      let udts = [];
      const stats = [];
      let totals;
      const ruleStats = [];
      const udtStats = [];
      this.statsObject = "statsObject";
      const nameId = "stats";
      const sortAlpha = function sortAlpha2(lhs, rhs) {
        if (lhs.lower < rhs.lower) {
          return -1;
        }
        if (lhs.lower > rhs.lower) {
          return 1;
        }
        return 0;
      };
      const sortHits = function sortHits2(lhs, rhs) {
        if (lhs.total < rhs.total) {
          return 1;
        }
        if (lhs.total > rhs.total) {
          return -1;
        }
        return sortAlpha(lhs, rhs);
      };
      const sortIndex = function sortIndex2(lhs, rhs) {
        if (lhs.index < rhs.index) {
          return -1;
        }
        if (lhs.index > rhs.index) {
          return 1;
        }
        return 0;
      };
      const EmptyStat = function EmptyStat2() {
        this.empty = 0;
        this.match = 0;
        this.nomatch = 0;
        this.total = 0;
      };
      const clear = function clear2() {
        stats.length = 0;
        totals = new EmptyStat();
        stats[id.ALT] = new EmptyStat();
        stats[id.CAT] = new EmptyStat();
        stats[id.REP] = new EmptyStat();
        stats[id.RNM] = new EmptyStat();
        stats[id.TRG] = new EmptyStat();
        stats[id.TBS] = new EmptyStat();
        stats[id.TLS] = new EmptyStat();
        stats[id.UDT] = new EmptyStat();
        stats[id.AND] = new EmptyStat();
        stats[id.NOT] = new EmptyStat();
        stats[id.BKR] = new EmptyStat();
        stats[id.BKA] = new EmptyStat();
        stats[id.BKN] = new EmptyStat();
        stats[id.ABG] = new EmptyStat();
        stats[id.AEN] = new EmptyStat();
        ruleStats.length = 0;
        for (let i = 0; i < rules.length; i += 1) {
          ruleStats.push({
            empty: 0,
            match: 0,
            nomatch: 0,
            total: 0,
            name: rules[i].name,
            lower: rules[i].lower,
            index: rules[i].index
          });
        }
        if (udts.length > 0) {
          udtStats.length = 0;
          for (let i = 0; i < udts.length; i += 1) {
            udtStats.push({
              empty: 0,
              match: 0,
              nomatch: 0,
              total: 0,
              name: udts[i].name,
              lower: udts[i].lower,
              index: udts[i].index
            });
          }
        }
      };
      const incStat = function incStat2(stat, state) {
        stat.total += 1;
        switch (state) {
          case id.EMPTY:
            stat.empty += 1;
            break;
          case id.MATCH:
            stat.match += 1;
            break;
          case id.NOMATCH:
            stat.nomatch += 1;
            break;
          default:
            throw new Error(`${thisFileName}collect(): incStat(): unrecognized state: ${state}`);
        }
      };
      const displayRow = function displayRow2(name, stat) {
        let html = "";
        html += "<tr>";
        html += `<td class="${style.CLASS_ACTIVE}">${name}</td>`;
        html += `<td class="${style.CLASS_EMPTY}">${stat.empty}</td>`;
        html += `<td class="${style.CLASS_MATCH}">${stat.match}</td>`;
        html += `<td class="${style.CLASS_NOMATCH}">${stat.nomatch}</td>`;
        html += `<td class="${style.CLASS_ACTIVE}">${stat.total}</td>`;
        html += "</tr>\n";
        return html;
      };
      const displayOpsOnly = function displayOpsOnly2() {
        let html = "";
        html += displayRow("ALT", stats[id.ALT]);
        html += displayRow("CAT", stats[id.CAT]);
        html += displayRow("REP", stats[id.REP]);
        html += displayRow("RNM", stats[id.RNM]);
        html += displayRow("TRG", stats[id.TRG]);
        html += displayRow("TBS", stats[id.TBS]);
        html += displayRow("TLS", stats[id.TLS]);
        html += displayRow("UDT", stats[id.UDT]);
        html += displayRow("AND", stats[id.AND]);
        html += displayRow("NOT", stats[id.NOT]);
        html += displayRow("BKR", stats[id.BKR]);
        html += displayRow("BKA", stats[id.BKA]);
        html += displayRow("BKN", stats[id.BKN]);
        html += displayRow("ABG", stats[id.ABG]);
        html += displayRow("AEN", stats[id.AEN]);
        html += displayRow("totals", totals);
        return html;
      };
      const displayRules = function displayRules2() {
        let html = "";
        html += "<tr><th></th><th></th><th></th><th></th><th></th></tr>\n";
        html += "<tr><th>rules</th><th></th><th></th><th></th><th></th></tr>\n";
        for (let i = 0; i < rules.length; i += 1) {
          if (ruleStats[i].total > 0) {
            html += "<tr>";
            html += `<td class="${style.CLASS_ACTIVE}">${ruleStats[i].name}</td>`;
            html += `<td class="${style.CLASS_EMPTY}">${ruleStats[i].empty}</td>`;
            html += `<td class="${style.CLASS_MATCH}">${ruleStats[i].match}</td>`;
            html += `<td class="${style.CLASS_NOMATCH}">${ruleStats[i].nomatch}</td>`;
            html += `<td class="${style.CLASS_ACTIVE}">${ruleStats[i].total}</td>`;
            html += "</tr>\n";
          }
        }
        if (udts.length > 0) {
          html += "<tr><th></th><th></th><th></th><th></th><th></th></tr>\n";
          html += "<tr><th>udts</th><th></th><th></th><th></th><th></th></tr>\n";
          for (let i = 0; i < udts.length; i += 1) {
            if (udtStats[i].total > 0) {
              html += "<tr>";
              html += `<td class="${style.CLASS_ACTIVE}">${udtStats[i].name}</td>`;
              html += `<td class="${style.CLASS_EMPTY}">${udtStats[i].empty}</td>`;
              html += `<td class="${style.CLASS_MATCH}">${udtStats[i].match}</td>`;
              html += `<td class="${style.CLASS_NOMATCH}">${udtStats[i].nomatch}</td>`;
              html += `<td class="${style.CLASS_ACTIVE}">${udtStats[i].total}</td>`;
              html += "</tr>\n";
            }
          }
        }
        return html;
      };
      this.validate = function validate(name) {
        let ret = false;
        if (typeof name === "string" && nameId === name) {
          ret = true;
        }
        return ret;
      };
      this.init = function init(inputRules, inputUdts) {
        rules = inputRules;
        udts = inputUdts;
        clear();
      };
      this.collect = function collect(op, result) {
        incStat(totals, result.state, result.phraseLength);
        incStat(stats[op.type], result.state, result.phraseLength);
        if (op.type === id.RNM) {
          incStat(ruleStats[op.index], result.state, result.phraseLength);
        }
        if (op.type === id.UDT) {
          incStat(udtStats[op.index], result.state, result.phraseLength);
        }
      };
      this.toHtml = function toHtml(type, caption) {
        let html = "";
        html += `<table class="${style.CLASS_STATS}">
`;
        if (typeof caption === "string") {
          html += `<caption>${caption}</caption>
`;
        }
        html += `<tr><th class="${style.CLASS_ACTIVE}">ops</th>
`;
        html += `<th class="${style.CLASS_EMPTY}">EMPTY</th>
`;
        html += `<th class="${style.CLASS_MATCH}">MATCH</th>
`;
        html += `<th class="${style.CLASS_NOMATCH}">NOMATCH</th>
`;
        html += `<th class="${style.CLASS_ACTIVE}">totals</th></tr>
`;
        const test = true;
        while (test) {
          if (type === void 0) {
            html += displayOpsOnly();
            break;
          }
          if (type === null) {
            html += displayOpsOnly();
            break;
          }
          if (type === "ops") {
            html += displayOpsOnly();
            break;
          }
          if (type === "index") {
            ruleStats.sort(sortIndex);
            if (udtStats.length > 0) {
              udtStats.sort(sortIndex);
            }
            html += displayOpsOnly();
            html += displayRules();
            break;
          }
          if (type === "hits") {
            ruleStats.sort(sortHits);
            if (udtStats.length > 0) {
              udtStats.sort(sortIndex);
            }
            html += displayOpsOnly();
            html += displayRules();
            break;
          }
          if (type === "alpha") {
            ruleStats.sort(sortAlpha);
            if (udtStats.length > 0) {
              udtStats.sort(sortAlpha);
            }
            html += displayOpsOnly();
            html += displayRules();
            break;
          }
          break;
        }
        html += "</table>\n";
        return html;
      };
      this.toHtmlPage = function toHtmlPage(type, caption, title) {
        return utils.htmlToPage(this.toHtml(type, caption), title);
      };
    };
  }
});

// node_modules/apg-js/src/apg-lib/trace.js
var require_trace = __commonJS({
  "node_modules/apg-js/src/apg-lib/trace.js"(exports, module) {
    module.exports = function exportTrace() {
      const utils = require_utilities();
      const style = require_style();
      const circular = new (require_circular_buffer())();
      const id = require_identifiers();
      const thisFileName = "trace.js: ";
      const that = this;
      const MODE_HEX = 16;
      const MODE_DEC = 10;
      const MODE_ASCII = 8;
      const MODE_UNICODE = 32;
      const MAX_PHRASE = 80;
      const MAX_TLS = 5;
      const records = [];
      let maxRecords = 5e3;
      let lastRecord = -1;
      let filteredRecords = 0;
      let treeDepth = 0;
      const recordStack = [];
      let chars = null;
      let rules = null;
      let udts = null;
      const operatorFilter = [];
      const ruleFilter = [];
      const PHRASE_END = `<span class="${style.CLASS_LINEEND}">&bull;</span>`;
      const PHRASE_CONTINUE = `<span class="${style.CLASS_LINEEND}">&hellip;</span>`;
      const PHRASE_EMPTY = `<span class="${style.CLASS_EMPTY}">&#120634;</span>`;
      const initOperatorFilter = function() {
        const setOperators = function(set) {
          operatorFilter[id.ALT] = set;
          operatorFilter[id.CAT] = set;
          operatorFilter[id.REP] = set;
          operatorFilter[id.TLS] = set;
          operatorFilter[id.TBS] = set;
          operatorFilter[id.TRG] = set;
          operatorFilter[id.AND] = set;
          operatorFilter[id.NOT] = set;
          operatorFilter[id.BKR] = set;
          operatorFilter[id.BKA] = set;
          operatorFilter[id.BKN] = set;
          operatorFilter[id.ABG] = set;
          operatorFilter[id.AEN] = set;
        };
        let items = 0;
        for (const name in that.filter.operators) {
          items += 1;
        }
        if (items === 0) {
          setOperators(false);
          return;
        }
        for (const name in that.filter.operators) {
          const upper = name.toUpperCase();
          if (upper === "<ALL>") {
            setOperators(true);
            return;
          }
          if (upper === "<NONE>") {
            setOperators(false);
            return;
          }
        }
        setOperators(false);
        for (const name in that.filter.operators) {
          const upper = name.toUpperCase();
          if (upper === "ALT") {
            operatorFilter[id.ALT] = that.filter.operators[name] === true;
          } else if (upper === "CAT") {
            operatorFilter[id.CAT] = that.filter.operators[name] === true;
          } else if (upper === "REP") {
            operatorFilter[id.REP] = that.filter.operators[name] === true;
          } else if (upper === "AND") {
            operatorFilter[id.AND] = that.filter.operators[name] === true;
          } else if (upper === "NOT") {
            operatorFilter[id.NOT] = that.filter.operators[name] === true;
          } else if (upper === "TLS") {
            operatorFilter[id.TLS] = that.filter.operators[name] === true;
          } else if (upper === "TBS") {
            operatorFilter[id.TBS] = that.filter.operators[name] === true;
          } else if (upper === "TRG") {
            operatorFilter[id.TRG] = that.filter.operators[name] === true;
          } else if (upper === "BKR") {
            operatorFilter[id.BKR] = that.filter.operators[name] === true;
          } else if (upper === "BKA") {
            operatorFilter[id.BKA] = that.filter.operators[name] === true;
          } else if (upper === "BKN") {
            operatorFilter[id.BKN] = that.filter.operators[name] === true;
          } else if (upper === "ABG") {
            operatorFilter[id.ABG] = that.filter.operators[name] === true;
          } else if (upper === "AEN") {
            operatorFilter[id.AEN] = that.filter.operators[name] === true;
          } else {
            throw new Error(
              `${thisFileName}initOpratorFilter: '${name}' not a valid operator name. Must be <all>, <none>, alt, cat, rep, tls, tbs, trg, and, not, bkr, bka or bkn`
            );
          }
        }
      };
      const initRuleFilter = function() {
        const setRules = function(set) {
          operatorFilter[id.RNM] = set;
          operatorFilter[id.UDT] = set;
          const count = rules.length + udts.length;
          ruleFilter.length = 0;
          for (let i2 = 0; i2 < count; i2 += 1) {
            ruleFilter.push(set);
          }
        };
        let items;
        let i;
        const list = [];
        for (i = 0; i < rules.length; i += 1) {
          list.push(rules[i].lower);
        }
        for (i = 0; i < udts.length; i += 1) {
          list.push(udts[i].lower);
        }
        ruleFilter.length = 0;
        items = 0;
        for (const name in that.filter.rules) {
          items += 1;
        }
        if (items === 0) {
          setRules(true);
          return;
        }
        for (const name in that.filter.rules) {
          const lower = name.toLowerCase();
          if (lower === "<all>") {
            setRules(true);
            return;
          }
          if (lower === "<none>") {
            setRules(false);
            return;
          }
        }
        setRules(false);
        operatorFilter[id.RNM] = true;
        operatorFilter[id.UDT] = true;
        for (const name in that.filter.rules) {
          const lower = name.toLowerCase();
          i = list.indexOf(lower);
          if (i < 0) {
            throw new Error(`${thisFileName}initRuleFilter: '${name}' not a valid rule or udt name`);
          }
          ruleFilter[i] = that.filter.rules[name] === true;
        }
      };
      this.traceObject = "traceObject";
      this.filter = {
        operators: [],
        rules: []
      };
      this.setMaxRecords = function(max, last) {
        lastRecord = -1;
        if (typeof max === "number" && max > 0) {
          maxRecords = Math.ceil(max);
        } else {
          maxRecords = 0;
          return;
        }
        if (typeof last === "number") {
          lastRecord = Math.floor(last);
          if (lastRecord < 0) {
            lastRecord = -1;
          }
        }
      };
      this.getMaxRecords = function() {
        return maxRecords;
      };
      this.getLastRecord = function() {
        return lastRecord;
      };
      this.init = function(rulesIn, udtsIn, charsIn) {
        records.length = 0;
        recordStack.length = 0;
        filteredRecords = 0;
        treeDepth = 0;
        chars = charsIn;
        rules = rulesIn;
        udts = udtsIn;
        initOperatorFilter();
        initRuleFilter();
        circular.init(maxRecords);
      };
      const filterOps = function(op) {
        let ret = false;
        if (op.type === id.RNM) {
          if (operatorFilter[op.type] && ruleFilter[op.index]) {
            ret = true;
          } else {
            ret = false;
          }
        } else if (op.type === id.UDT) {
          if (operatorFilter[op.type] && ruleFilter[rules.length + op.index]) {
            ret = true;
          } else {
            ret = false;
          }
        } else {
          ret = operatorFilter[op.type];
        }
        return ret;
      };
      const filterRecords = function(record) {
        if (lastRecord === -1) {
          return true;
        }
        if (record <= lastRecord) {
          return true;
        }
        return false;
      };
      this.down = function(op, state, offset, length, anchor, lookAround) {
        if (filterRecords(filteredRecords) && filterOps(op)) {
          recordStack.push(filteredRecords);
          records[circular.increment()] = {
            dirUp: false,
            depth: treeDepth,
            thisLine: filteredRecords,
            thatLine: void 0,
            opcode: op,
            state,
            phraseIndex: offset,
            phraseLength: length,
            lookAnchor: anchor,
            lookAround
          };
          filteredRecords += 1;
          treeDepth += 1;
        }
      };
      this.up = function(op, state, offset, length, anchor, lookAround) {
        if (filterRecords(filteredRecords) && filterOps(op)) {
          const thisLine = filteredRecords;
          const thatLine = recordStack.pop();
          const thatRecord = circular.getListIndex(thatLine);
          if (thatRecord !== -1) {
            records[thatRecord].thatLine = thisLine;
          }
          treeDepth -= 1;
          records[circular.increment()] = {
            dirUp: true,
            depth: treeDepth,
            thisLine,
            thatLine,
            opcode: op,
            state,
            phraseIndex: offset,
            phraseLength: length,
            lookAnchor: anchor,
            lookAround
          };
          filteredRecords += 1;
        }
      };
      const toTreeObj = function() {
        function nodeOpcode(node2, opcode) {
          let name;
          let casetype;
          let modetype;
          if (opcode) {
            node2.op = { id: opcode.type, name: utils.opcodeToString(opcode.type) };
            node2.opData = void 0;
            switch (opcode.type) {
              case id.RNM:
                node2.opData = rules[opcode.index].name;
                break;
              case id.UDT:
                node2.opData = udts[opcode.index].name;
                break;
              case id.BKR:
                if (opcode.index < rules.length) {
                  name = rules[opcode.index].name;
                } else {
                  name = udts[opcode.index - rules.length].name;
                }
                casetype = opcode.bkrCase === id.BKR_MODE_CI ? "%i" : "%s";
                modetype = opcode.bkrMode === id.BKR_MODE_UM ? "%u" : "%p";
                node2.opData = `\\\\${casetype}${modetype}${name}`;
                break;
              case id.TLS:
                node2.opData = [];
                for (let i = 0; i < opcode.string.length; i += 1) {
                  node2.opData.push(opcode.string[i]);
                }
                break;
              case id.TBS:
                node2.opData = [];
                for (let i = 0; i < opcode.string.length; i += 1) {
                  node2.opData.push(opcode.string[i]);
                }
                break;
              case id.TRG:
                node2.opData = [opcode.min, opcode.max];
                break;
              case id.REP:
                node2.opData = [opcode.min, opcode.max];
                break;
              default:
                throw new Error("unrecognized opcode");
            }
          } else {
            node2.op = { id: void 0, name: void 0 };
            node2.opData = void 0;
          }
        }
        function nodePhrase(state, index, length) {
          if (state === id.MATCH) {
            return {
              index,
              length
            };
          }
          if (state === id.NOMATCH) {
            return {
              index,
              length: 0
            };
          }
          if (state === id.EMPTY) {
            return {
              index,
              length: 0
            };
          }
          return null;
        }
        let nodeId = -1;
        function nodeDown(parent2, record2, depth2) {
          const node2 = {
            // eslint-disable-next-line no-plusplus
            id: nodeId++,
            branch: -1,
            parent: parent2,
            up: false,
            down: false,
            depth: depth2,
            children: []
          };
          if (record2) {
            node2.down = true;
            node2.state = { id: record2.state, name: utils.stateToString(record2.state) };
            node2.phrase = null;
            nodeOpcode(node2, record2.opcode);
          } else {
            node2.state = { id: void 0, name: void 0 };
            node2.phrase = nodePhrase();
            nodeOpcode(node2, void 0);
          }
          return node2;
        }
        function nodeUp(node2, record2) {
          if (record2) {
            node2.up = true;
            node2.state = { id: record2.state, name: utils.stateToString(record2.state) };
            node2.phrase = nodePhrase(record2.state, record2.phraseIndex, record2.phraseLength);
            if (!node2.down) {
              nodeOpcode(node2, record2.opcode);
            }
          }
        }
        let leafNodes = 0;
        let depth = -1;
        let branchCount = 1;
        function walk(node2) {
          depth += 1;
          node2.branch = branchCount;
          if (depth > treeDepth) {
            treeDepth = depth;
          }
          if (node2.children.length === 0) {
            leafNodes += 1;
          } else {
            for (let i = 0; i < node2.children.length; i += 1) {
              if (i > 0) {
                branchCount += 1;
              }
              node2.children[i].leftMost = false;
              node2.children[i].rightMost = false;
              if (node2.leftMost) {
                node2.children[i].leftMost = i === 0;
              }
              if (node2.rightMost) {
                node2.children[i].rightMost = i === node2.children.length - 1;
              }
              walk(node2.children[i]);
            }
          }
          depth -= 1;
        }
        function display(node2, offset) {
          let name;
          const obj2 = {};
          obj2.id = node2.id;
          obj2.branch = node2.branch;
          obj2.leftMost = node2.leftMost;
          obj2.rightMost = node2.rightMost;
          name = node2.state.name ? node2.state.name : "ACTIVE";
          obj2.state = { id: node2.state.id, name };
          name = node2.op.name ? node2.op.name : "?";
          obj2.op = { id: node2.op.id, name };
          if (typeof node2.opData === "string") {
            obj2.opData = node2.opData;
          } else if (Array.isArray(node2.opData)) {
            obj2.opData = [];
            for (let i = 0; i < node2.opData.length; i += 1) {
              obj2.opData[i] = node2.opData[i];
            }
          } else {
            obj2.opData = void 0;
          }
          if (node2.phrase) {
            obj2.phrase = { index: node2.phrase.index, length: node2.phrase.length };
          } else {
            obj2.phrase = null;
          }
          obj2.depth = node2.depth;
          obj2.children = [];
          for (let i = 0; i < node2.children.length; i += 1) {
            const c = i !== node2.children.length - 1;
            obj2.children[i] = display(node2.children[i], offset, c);
          }
          return obj2;
        }
        const branch = [];
        let root;
        let node;
        let parent;
        let record;
        let firstRecord = true;
        const dummy = nodeDown(null, null, -1);
        branch.push(dummy);
        node = dummy;
        circular.forEach((lineIndex) => {
          record = records[lineIndex];
          if (firstRecord) {
            firstRecord = false;
            if (record.depth > 0) {
              const num = record.dirUp ? record.depth + 1 : record.depth;
              for (let i = 0; i < num; i += 1) {
                parent = node;
                node = nodeDown(node, null, i);
                branch.push(node);
                parent.children.push(node);
              }
            }
          }
          if (record.dirUp) {
            node = branch.pop();
            nodeUp(node, record);
            node = branch[branch.length - 1];
          } else {
            parent = node;
            node = nodeDown(node, record, record.depth);
            branch.push(node);
            parent.children.push(node);
          }
        });
        while (branch.length > 1) {
          node = branch.pop();
          nodeUp(node, null);
        }
        if (dummy.children.length === 0) {
          throw new Error("trace.toTree(): parse tree has no nodes");
        }
        if (branch.length === 0) {
          throw new Error("trace.toTree(): integrity check: dummy root node disappeared?");
        }
        root = dummy.children[0];
        let prev = root;
        while (root && !root.down && !root.up) {
          prev = root;
          root = root.children[0];
        }
        root = prev;
        root.leftMost = true;
        root.rightMost = true;
        walk(root);
        root.branch = 0;
        const obj = {};
        obj.string = [];
        for (let i = 0; i < chars.length; i += 1) {
          obj.string[i] = chars[i];
        }
        obj.rules = [];
        for (let i = 0; i < rules.length; i += 1) {
          obj.rules[i] = rules[i].name;
        }
        obj.udts = [];
        for (let i = 0; i < udts.length; i += 1) {
          obj.udts[i] = udts[i].name;
        }
        obj.id = {};
        obj.id.ALT = { id: id.ALT, name: "ALT" };
        obj.id.CAT = { id: id.CAT, name: "CAT" };
        obj.id.REP = { id: id.REP, name: "REP" };
        obj.id.RNM = { id: id.RNM, name: "RNM" };
        obj.id.TLS = { id: id.TLS, name: "TLS" };
        obj.id.TBS = { id: id.TBS, name: "TBS" };
        obj.id.TRG = { id: id.TRG, name: "TRG" };
        obj.id.UDT = { id: id.UDT, name: "UDT" };
        obj.id.AND = { id: id.AND, name: "AND" };
        obj.id.NOT = { id: id.NOT, name: "NOT" };
        obj.id.BKR = { id: id.BKR, name: "BKR" };
        obj.id.BKA = { id: id.BKA, name: "BKA" };
        obj.id.BKN = { id: id.BKN, name: "BKN" };
        obj.id.ABG = { id: id.ABG, name: "ABG" };
        obj.id.AEN = { id: id.AEN, name: "AEN" };
        obj.id.ACTIVE = { id: id.ACTIVE, name: "ACTIVE" };
        obj.id.MATCH = { id: id.MATCH, name: "MATCH" };
        obj.id.EMPTY = { id: id.EMPTY, name: "EMPTY" };
        obj.id.NOMATCH = { id: id.NOMATCH, name: "NOMATCH" };
        obj.treeDepth = treeDepth;
        obj.leafNodes = leafNodes;
        let branchesIncomplete;
        if (root.down) {
          if (root.up) {
            branchesIncomplete = "none";
          } else {
            branchesIncomplete = "right";
          }
        } else if (root.up) {
          branchesIncomplete = "left";
        } else {
          branchesIncomplete = "both";
        }
        obj.branchesIncomplete = branchesIncomplete;
        obj.tree = display(root, root.depth, false);
        return obj;
      };
      this.toTree = function(stringify) {
        const obj = toTreeObj();
        if (stringify) {
          return JSON.stringify(obj);
        }
        return obj;
      };
      this.toHtmlPage = function(mode, caption, title) {
        return utils.htmlToPage(this.toHtml(mode, caption), title);
      };
      const htmlHeader = function(mode, caption) {
        let modeName;
        switch (mode) {
          case MODE_HEX:
            modeName = "hexadecimal";
            break;
          case MODE_DEC:
            modeName = "decimal";
            break;
          case MODE_ASCII:
            modeName = "ASCII";
            break;
          case MODE_UNICODE:
            modeName = "UNICODE";
            break;
          default:
            throw new Error(`${thisFileName}htmlHeader: unrecognized mode: ${mode}`);
        }
        let header = "";
        header += `<p>display mode: ${modeName}</p>
`;
        header += `<table class="${style.CLASS_TRACE}">
`;
        if (typeof caption === "string") {
          header += `<caption>${caption}</caption>`;
        }
        return header;
      };
      const htmlFooter = function() {
        let footer = "";
        footer += "</table>\n";
        footer += `<p class="${style.CLASS_MONOSPACE}">legend:<br>
`;
        footer += "(a)&nbsp;-&nbsp;line number<br>\n";
        footer += "(b)&nbsp;-&nbsp;matching line number<br>\n";
        footer += "(c)&nbsp;-&nbsp;phrase offset<br>\n";
        footer += "(d)&nbsp;-&nbsp;phrase length<br>\n";
        footer += "(e)&nbsp;-&nbsp;tree depth<br>\n";
        footer += "(f)&nbsp;-&nbsp;operator state<br>\n";
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_ACTIVE}">&darr;</span>&nbsp;&nbsp;phrase opened<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_MATCH}">&uarr;M</span> phrase matched<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_EMPTY}">&uarr;E</span> empty phrase matched<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_NOMATCH}">&uarr;N</span> phrase not matched<br>
`;
        footer += "operator&nbsp;-&nbsp;ALT, CAT, REP, RNM, TRG, TLS, TBS<sup>&dagger;</sup>, UDT, AND, NOT, BKA, BKN, BKR, ABG, AEN<sup>&Dagger;</sup><br>\n";
        footer += `phrase&nbsp;&nbsp;&nbsp;-&nbsp;up to ${MAX_PHRASE} characters of the phrase being matched<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_MATCH}">matched characters</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_LOOKAHEAD}">matched characters in look ahead mode</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_LOOKBEHIND}">matched characters in look behind mode</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_REMAINDER}">remainder characters(not yet examined by parser)</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style.CLASS_CTRLCHAR}">control characters, TAB, LF, CR, etc. (ASCII mode only)</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_EMPTY} empty string<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_END} end of input string<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_CONTINUE} input string display truncated<br>
`;
        footer += "</p>\n";
        footer += `<p class="${style.CLASS_MONOSPACE}">
`;
        footer += "<sup>&dagger;</sup>original ABNF operators:<br>\n";
        footer += "ALT - alternation<br>\n";
        footer += "CAT - concatenation<br>\n";
        footer += "REP - repetition<br>\n";
        footer += "RNM - rule name<br>\n";
        footer += "TRG - terminal range<br>\n";
        footer += "TLS - terminal literal string (case insensitive)<br>\n";
        footer += "TBS - terminal binary string (case sensitive)<br>\n";
        footer += "<br>\n";
        footer += "<sup>&Dagger;</sup>super set SABNF operators:<br>\n";
        footer += "UDT - user-defined terminal<br>\n";
        footer += "AND - positive look ahead<br>\n";
        footer += "NOT - negative look ahead<br>\n";
        footer += "BKA - positive look behind<br>\n";
        footer += "BKN - negative look behind<br>\n";
        footer += "BKR - back reference<br>\n";
        footer += "ABG - anchor - begin of input string<br>\n";
        footer += "AEN - anchor - end of input string<br>\n";
        footer += "</p>\n";
        return footer;
      };
      this.indent = function(depth) {
        let html = "";
        for (let i = 0; i < depth; i += 1) {
          html += ".";
        }
        return html;
      };
      const displayTrg = function(mode, op) {
        let html = "";
        if (op.type === id.TRG) {
          if (mode === MODE_HEX || mode === MODE_UNICODE) {
            let hex = op.min.toString(16).toUpperCase();
            if (hex.length % 2 !== 0) {
              hex = `0${hex}`;
            }
            html += mode === MODE_HEX ? "%x" : "U+";
            html += hex;
            hex = op.max.toString(16).toUpperCase();
            if (hex.length % 2 !== 0) {
              hex = `0${hex}`;
            }
            html += `&ndash;${hex}`;
          } else {
            html = `%d${op.min.toString(10)}&ndash;${op.max.toString(10)}`;
          }
        }
        return html;
      };
      const displayRep = function(mode, op) {
        let html = "";
        if (op.type === id.REP) {
          if (mode === MODE_HEX) {
            let hex = op.min.toString(16).toUpperCase();
            if (hex.length % 2 !== 0) {
              hex = `0${hex}`;
            }
            html = `x${hex}`;
            if (op.max < Infinity) {
              hex = op.max.toString(16).toUpperCase();
              if (hex.length % 2 !== 0) {
                hex = `0${hex}`;
              }
            } else {
              hex = "inf";
            }
            html += `&ndash;${hex}`;
          } else if (op.max < Infinity) {
            html = `${op.min.toString(10)}&ndash;${op.max.toString(10)}`;
          } else {
            html = `${op.min.toString(10)}&ndash;inf`;
          }
        }
        return html;
      };
      const displayTbs = function(mode, op) {
        let html = "";
        if (op.type === id.TBS) {
          const len = Math.min(op.string.length, MAX_TLS * 2);
          if (mode === MODE_HEX || mode === MODE_UNICODE) {
            html += mode === MODE_HEX ? "%x" : "U+";
            for (let i = 0; i < len; i += 1) {
              let hex;
              if (i > 0) {
                html += ".";
              }
              hex = op.string[i].toString(16).toUpperCase();
              if (hex.length % 2 !== 0) {
                hex = `0${hex}`;
              }
              html += hex;
            }
          } else {
            html = "%d";
            for (let i = 0; i < len; i += 1) {
              if (i > 0) {
                html += ".";
              }
              html += op.string[i].toString(10);
            }
          }
          if (len < op.string.length) {
            html += PHRASE_CONTINUE;
          }
        }
        return html;
      };
      const displayTls = function(mode, op) {
        let html = "";
        if (op.type === id.TLS) {
          const len = Math.min(op.string.length, MAX_TLS);
          if (mode === MODE_HEX || mode === MODE_DEC) {
            let charu;
            let charl;
            let base;
            if (mode === MODE_HEX) {
              html = "%x";
              base = 16;
            } else {
              html = "%d";
              base = 10;
            }
            for (let i = 0; i < len; i += 1) {
              if (i > 0) {
                html += ".";
              }
              charl = op.string[i];
              if (charl >= 97 && charl <= 122) {
                charu = charl - 32;
                html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();
              } else if (charl >= 65 && charl <= 90) {
                charu = charl;
                charl += 32;
                html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();
              } else {
                html += charl.toString(base).toUpperCase();
              }
            }
            if (len < op.string.length) {
              html += PHRASE_CONTINUE;
            }
          } else {
            html = '"';
            for (let i = 0; i < len; i += 1) {
              html += utils.asciiChars[op.string[i]];
            }
            if (len < op.string.length) {
              html += PHRASE_CONTINUE;
            }
            html += '"';
          }
        }
        return html;
      };
      const subPhrase = function(mode, charsArg, index, length, prev) {
        if (length === 0) {
          return "";
        }
        let phrase = "";
        const comma = prev ? "," : "";
        switch (mode) {
          case MODE_HEX:
            phrase = comma + utils.charsToHex(charsArg, index, length);
            break;
          case MODE_DEC:
            if (prev) {
              return `,${utils.charsToDec(charsArg, index, length)}`;
            }
            phrase = comma + utils.charsToDec(charsArg, index, length);
            break;
          case MODE_UNICODE:
            phrase = utils.charsToUnicode(charsArg, index, length);
            break;
          case MODE_ASCII:
          default:
            phrase = utils.charsToAsciiHtml(charsArg, index, length);
            break;
        }
        return phrase;
      };
      const displayBehind = function(mode, charsArg, state, index, length, anchor) {
        let html = "";
        let beg1;
        let len1;
        let beg2;
        let len2;
        let lastchar = PHRASE_END;
        const spanBehind = `<span class="${style.CLASS_LOOKBEHIND}">`;
        const spanRemainder = `<span class="${style.CLASS_REMAINDER}">`;
        const spanend = "</span>";
        let prev = false;
        switch (state) {
          case id.EMPTY:
            html += PHRASE_EMPTY;
          /* // eslint-disable-next-line no-fallthrough */
          case id.NOMATCH:
          case id.MATCH:
          case id.ACTIVE:
            beg1 = index - length;
            len1 = anchor - beg1;
            beg2 = anchor;
            len2 = charsArg.length - beg2;
            break;
          default:
            throw new Error("unrecognized state");
        }
        lastchar = PHRASE_END;
        if (len1 > MAX_PHRASE) {
          len1 = MAX_PHRASE;
          lastchar = PHRASE_CONTINUE;
          len2 = 0;
        } else if (len1 + len2 > MAX_PHRASE) {
          lastchar = PHRASE_CONTINUE;
          len2 = MAX_PHRASE - len1;
        }
        if (len1 > 0) {
          html += spanBehind;
          html += subPhrase(mode, charsArg, beg1, len1, prev);
          html += spanend;
          prev = true;
        }
        if (len2 > 0) {
          html += spanRemainder;
          html += subPhrase(mode, charsArg, beg2, len2, prev);
          html += spanend;
        }
        return html + lastchar;
      };
      const displayForward = function(mode, charsArg, state, index, length, spanAhead) {
        let html = "";
        let beg1;
        let len1;
        let beg2;
        let len2;
        let lastchar = PHRASE_END;
        const spanRemainder = `<span class="${style.CLASS_REMAINDER}">`;
        const spanend = "</span>";
        let prev = false;
        switch (state) {
          case id.EMPTY:
            html += PHRASE_EMPTY;
          /* // eslint-disable-next-line no-fallthrough */
          case id.NOMATCH:
          case id.ACTIVE:
            beg1 = index;
            len1 = 0;
            beg2 = index;
            len2 = charsArg.length - beg2;
            break;
          case id.MATCH:
            beg1 = index;
            len1 = length;
            beg2 = index + len1;
            len2 = charsArg.length - beg2;
            break;
          default:
            throw new Error("unrecognized state");
        }
        lastchar = PHRASE_END;
        if (len1 > MAX_PHRASE) {
          len1 = MAX_PHRASE;
          lastchar = PHRASE_CONTINUE;
          len2 = 0;
        } else if (len1 + len2 > MAX_PHRASE) {
          lastchar = PHRASE_CONTINUE;
          len2 = MAX_PHRASE - len1;
        }
        if (len1 > 0) {
          html += spanAhead;
          html += subPhrase(mode, charsArg, beg1, len1, prev);
          html += spanend;
          prev = true;
        }
        if (len2 > 0) {
          html += spanRemainder;
          html += subPhrase(mode, charsArg, beg2, len2, prev);
          html += spanend;
        }
        return html + lastchar;
      };
      const displayAhead = function(mode, charsArg, state, index, length) {
        const spanAhead = `<span class="${style.CLASS_LOOKAHEAD}">`;
        return displayForward(mode, charsArg, state, index, length, spanAhead);
      };
      const displayNone = function(mode, charsArg, state, index, length) {
        const spanAhead = `<span class="${style.CLASS_MATCH}">`;
        return displayForward(mode, charsArg, state, index, length, spanAhead);
      };
      const htmlTable = function(mode) {
        if (rules === null) {
          return "";
        }
        let html = "";
        let thisLine;
        let thatLine;
        let lookAhead;
        let lookBehind;
        let lookAround;
        let anchor;
        html += "<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>";
        html += "<th>operator</th><th>phrase</th></tr>\n";
        circular.forEach((lineIndex) => {
          const line = records[lineIndex];
          thisLine = line.thisLine;
          thatLine = line.thatLine !== void 0 ? line.thatLine : "--";
          lookAhead = false;
          lookBehind = false;
          lookAround = false;
          if (line.lookAround === id.LOOKAROUND_AHEAD) {
            lookAhead = true;
            lookAround = true;
            anchor = line.lookAnchor;
          }
          if (line.opcode.type === id.AND || line.opcode.type === id.NOT) {
            lookAhead = true;
            lookAround = true;
            anchor = line.phraseIndex;
          }
          if (line.lookAround === id.LOOKAROUND_BEHIND) {
            lookBehind = true;
            lookAround = true;
            anchor = line.lookAnchor;
          }
          if (line.opcode.type === id.BKA || line.opcode.type === id.BKN) {
            lookBehind = true;
            lookAround = true;
            anchor = line.phraseIndex;
          }
          html += "<tr>";
          html += `<td>${thisLine}</td><td>${thatLine}</td>`;
          html += `<td>${line.phraseIndex}</td>`;
          html += `<td>${line.phraseLength}</td>`;
          html += `<td>${line.depth}</td>`;
          html += "<td>";
          switch (line.state) {
            case id.ACTIVE:
              html += `<span class="${style.CLASS_ACTIVE}">&darr;&nbsp;</span>`;
              break;
            case id.MATCH:
              html += `<span class="${style.CLASS_MATCH}">&uarr;M</span>`;
              break;
            case id.NOMATCH:
              html += `<span class="${style.CLASS_NOMATCH}">&uarr;N</span>`;
              break;
            case id.EMPTY:
              html += `<span class="${style.CLASS_EMPTY}">&uarr;E</span>`;
              break;
            default:
              html += `<span class="${style.CLASS_ACTIVE}">--</span>`;
              break;
          }
          html += "</td>";
          html += "<td>";
          html += that.indent(line.depth);
          if (lookAhead) {
            html += `<span class="${style.CLASS_LOOKAHEAD}">`;
          } else if (lookBehind) {
            html += `<span class="${style.CLASS_LOOKBEHIND}">`;
          }
          html += utils.opcodeToString(line.opcode.type);
          if (line.opcode.type === id.RNM) {
            html += `(${rules[line.opcode.index].name}) `;
          }
          if (line.opcode.type === id.BKR) {
            const casetype = line.opcode.bkrCase === id.BKR_MODE_CI ? "%i" : "%s";
            const modetype = line.opcode.bkrMode === id.BKR_MODE_UM ? "%u" : "%p";
            html += `(\\${casetype}${modetype}${rules[line.opcode.index].name}) `;
          }
          if (line.opcode.type === id.UDT) {
            html += `(${udts[line.opcode.index].name}) `;
          }
          if (line.opcode.type === id.TRG) {
            html += `(${displayTrg(mode, line.opcode)}) `;
          }
          if (line.opcode.type === id.TBS) {
            html += `(${displayTbs(mode, line.opcode)}) `;
          }
          if (line.opcode.type === id.TLS) {
            html += `(${displayTls(mode, line.opcode)}) `;
          }
          if (line.opcode.type === id.REP) {
            html += `(${displayRep(mode, line.opcode)}) `;
          }
          if (lookAround) {
            html += "</span>";
          }
          html += "</td>";
          html += "<td>";
          if (lookBehind) {
            html += displayBehind(mode, chars, line.state, line.phraseIndex, line.phraseLength, anchor);
          } else if (lookAhead) {
            html += displayAhead(mode, chars, line.state, line.phraseIndex, line.phraseLength);
          } else {
            html += displayNone(mode, chars, line.state, line.phraseIndex, line.phraseLength);
          }
          html += "</td></tr>\n";
        });
        html += "<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>";
        html += "<th>operator</th><th>phrase</th></tr>\n";
        html += "</table>\n";
        return html;
      };
      this.toHtml = function(modearg, caption) {
        let mode = MODE_ASCII;
        if (typeof modearg === "string" && modearg.length >= 3) {
          const modein = modearg.toLowerCase().slice(0, 3);
          if (modein === "hex") {
            mode = MODE_HEX;
          } else if (modein === "dec") {
            mode = MODE_DEC;
          } else if (modein === "uni") {
            mode = MODE_UNICODE;
          }
        }
        let html = "";
        html += htmlHeader(mode, caption);
        html += htmlTable(mode);
        html += htmlFooter();
        return html;
      };
    };
  }
});

// node_modules/apg-js/src/apg-lib/node-exports.js
var require_node_exports = __commonJS({
  "node_modules/apg-js/src/apg-lib/node-exports.js"(exports, module) {
    module.exports = {
      ast: require_ast(),
      circular: require_circular_buffer(),
      ids: require_identifiers(),
      parser: require_parser(),
      stats: require_stats(),
      trace: require_trace(),
      utils: require_utilities(),
      emitcss: require_emitcss(),
      style: require_style()
    };
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
    exports.add = add;
    exports.fromBig = fromBig;
    exports.split = split;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    function split(lst, le = false) {
      const len = lst.length;
      let Ah = new Uint32Array(len);
      let Al = new Uint32Array(len);
      for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
    exports.isBytes = isBytes;
    exports.anumber = anumber;
    exports.abytes = abytes;
    exports.ahash = ahash;
    exports.aexists = aexists;
    exports.aoutput = aoutput;
    exports.u8 = u8;
    exports.u32 = u32;
    exports.clean = clean;
    exports.createView = createView;
    exports.rotr = rotr;
    exports.rotl = rotl;
    exports.byteSwap = byteSwap;
    exports.byteSwap32 = byteSwap32;
    exports.bytesToHex = bytesToHex;
    exports.hexToBytes = hexToBytes;
    exports.asyncLoop = asyncLoop;
    exports.utf8ToBytes = utf8ToBytes;
    exports.bytesToUtf8 = bytesToUtf8;
    exports.toBytes = toBytes;
    exports.kdfInputToBytes = kdfInputToBytes;
    exports.concatBytes = concatBytes;
    exports.checkOpts = checkOpts;
    exports.createHasher = createHasher;
    exports.createOptHasher = createOptHasher;
    exports.createXOFer = createXOFer;
    exports.randomBytes = randomBytes;
    var crypto_1 = require_crypto();
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports.swap8IfBE = exports.isLE ? (n) => n : (n) => byteSwap(n);
    exports.byteSwapIfBE = exports.swap8IfBE;
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
      }
      return arr;
    }
    exports.swap32IfBE = exports.isLE ? (u) => u : byteSwap32;
    var hasHexBuiltin = (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      if (hasHexBuiltin)
        return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function kdfInputToBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    var Hash = class {
    };
    exports.Hash = Hash;
    function createHasher(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createOptHasher(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function createXOFer(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructor = createHasher;
    exports.wrapConstructorWithOpts = createOptHasher;
    exports.wrapXOFConstructorWithOpts = createXOFer;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
    exports.keccakP = keccakP;
    var _u64_ts_1 = require_u64();
    var utils_ts_1 = require_utils();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    var SHA3_PI = [];
    var SHA3_ROTL = [];
    var _SHA3_IOTA = [];
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
    var SHA3_IOTA_H = IOTAS[0];
    var SHA3_IOTA_L = IOTAS[1];
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      (0, utils_ts_1.clean)(B);
    }
    var Keccak = class _Keccak extends utils_ts_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        (0, utils_ts_1.anumber)(outputLen);
        if (!(0 < blockLen && blockLen < 200))
          throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
      }
      clone() {
        return this._cloneInto();
      }
      keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { blockLen, state } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = (() => gen(6, 144, 224 / 8))();
    exports.sha3_256 = (() => gen(6, 136, 256 / 8))();
    exports.sha3_384 = (() => gen(6, 104, 384 / 8))();
    exports.sha3_512 = (() => gen(6, 72, 512 / 8))();
    exports.keccak_224 = (() => gen(1, 144, 224 / 8))();
    exports.keccak_256 = (() => gen(1, 136, 256 / 8))();
    exports.keccak_384 = (() => gen(1, 104, 384 / 8))();
    exports.keccak_512 = (() => gen(1, 72, 512 / 8))();
    var genShake = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = (() => genShake(31, 168, 128 / 8))();
    exports.shake256 = (() => genShake(31, 136, 256 / 8))();
  }
});

// node_modules/@spruceid/siwe-parser/dist/utils.js
var require_utils2 = __commonJS({
  "node_modules/@spruceid/siwe-parser/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseIntegerNumber = exports.isEIP55Address = void 0;
    var sha3_1 = require_sha3();
    var utils_1 = require_utils();
    var isEIP55Address = (address) => {
      if (address.length != 42) {
        return false;
      }
      const lowerAddress = `${address}`.toLowerCase().replace("0x", "");
      const hash = (0, utils_1.bytesToHex)((0, sha3_1.keccak_256)(lowerAddress));
      let ret = "0x";
      for (let i = 0; i < lowerAddress.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
          ret += lowerAddress[i].toUpperCase();
        } else {
          ret += lowerAddress[i];
        }
      }
      return address === ret;
    };
    exports.isEIP55Address = isEIP55Address;
    var parseIntegerNumber = (number) => {
      const parsed = parseInt(number);
      if (isNaN(parsed))
        throw new Error("Invalid number.");
      if (parsed === Infinity)
        throw new Error("Invalid number.");
      return parsed;
    };
    exports.parseIntegerNumber = parseIntegerNumber;
  }
});

// node_modules/@spruceid/siwe-parser/dist/callbacks.js
var require_callbacks = __commonJS({
  "node_modules/@spruceid/siwe-parser/dist/callbacks.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cb = void 0;
    var node_exports_1 = __importDefault(require_node_exports());
    var utils = node_exports_1.default.utils;
    var id = node_exports_1.default.ids;
    var utils_1 = require_utils2();
    var ISO8601 = /^(?<date>[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(.[0-9]+)?(([Zz])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
    var isValidISO8601Date = (inputDate) => {
      const inputMatch = ISO8601.exec(inputDate);
      if (!inputMatch) {
        return false;
      }
      const inputDateParsed = new Date(inputMatch.groups.date).toISOString();
      const parsedInputMatch = ISO8601.exec(inputDateParsed);
      return inputMatch.groups.date === parsedInputMatch.groups.date;
    };
    exports.cb = {
      signInWithEtherium: function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            if (typeof data !== "object" || data === null) {
              throw new Error("data must be an object");
            }
            break;
          case id.NOMATCH:
            data.errors.push(`invalid message: max line number was ${data.lineno}`);
        }
      },
      lineno: function lineno(result, chars, phraseIndex, data) {
        if (result.state === id.MATCH) {
          data.lineno += 1;
        }
      },
      exTitle: function exTitle(result, chars, phraseIndex, data) {
        if (result.state === id.NOMATCH) {
          data.lineno -= 1;
        }
      },
      nbTitle: function nbTitle(result, chars, phraseIndex, data) {
        if (result.state === id.NOMATCH) {
          data.lineno -= 1;
        }
      },
      riTitle: function riTitle(result, chars, phraseIndex, data) {
        if (result.state === id.NOMATCH) {
          data.lineno -= 1;
        }
      },
      reTitle: function reTitle(result, chars, phraseIndex, data) {
        if (result.state === id.MATCH) {
          data.resources = [];
        } else if (result.state === id.NOMATCH) {
          data.lineno -= 1;
        }
      },
      oscheme: function oscheme(result, chars, phraseIndex, data) {
        if (result.state === id.MATCH) {
          data.scheme = utils.charsToString(chars, phraseIndex, result.phraseLength - 3);
        }
      },
      domain: function domain(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.domain = utils.charsToString(chars, phraseIndex, result.phraseLength);
            break;
          case id.EMPTY:
            data.errors.push(`line ${data.lineno}: domain cannot be empty`);
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid domain`);
        }
      },
      address: function address(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.address = utils.charsToString(chars, phraseIndex, result.phraseLength);
            if (!(0, utils_1.isEIP55Address)(data.address)) {
              data.errors.push(`line ${data.lineno}: invalid EIP-55 address - ${data.address}`);
            }
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid address`);
            break;
        }
      },
      statement: function statement(result, chars, phraseIndex, data) {
        if (result.state === id.MATCH) {
          data.statement = utils.charsToString(chars, phraseIndex, result.phraseLength);
        }
      },
      emptyStatement: function emptyStatement(result, chars, phraseIndex, data) {
        if (result.state === id.MATCH) {
          data.statement = "";
        }
      },
      version: function version(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.version = utils.charsToString(chars, phraseIndex, result.phraseLength);
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid version`);
            break;
        }
      },
      nonce: function nonce(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.nonce = utils.charsToString(chars, phraseIndex, result.phraseLength);
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid nonce`);
            break;
        }
      },
      issuedAt: function issuedAt(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.issuedAt = utils.charsToString(chars, phraseIndex, result.phraseLength);
            if (!isValidISO8601Date(data.issuedAt)) {
              data.errors.push(`line ${data.lineno}: invalid issued-at date time semantics`);
            }
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid issued-at date time syntax`);
            break;
        }
      },
      expirationTime: function expirationTime(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.expirationTime = utils.charsToString(chars, phraseIndex, result.phraseLength);
            if (!isValidISO8601Date(data.expirationTime)) {
              data.errors.push(`line ${data.lineno}: invalid expiration-time date time semantics`);
            }
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid expiration-time date time syntax`);
            break;
        }
      },
      notBefore: function notBefore(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.notBefore = utils.charsToString(chars, phraseIndex, result.phraseLength);
            if (!isValidISO8601Date(data.notBefore)) {
              data.errors.push(`line ${data.lineno}: invalid not-before date time semantics`);
            }
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid not-before date time syntax`);
            break;
        }
      },
      requestId: function requestId(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.requestId = utils.charsToString(chars, phraseIndex, result.phraseLength);
            break;
          case id.EMPTY:
            data.requestId = "";
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid requestID`);
            break;
        }
      },
      chainId: function chainId(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.chainId = (0, utils_1.parseIntegerNumber)(utils.charsToString(chars, phraseIndex, result.phraseLength));
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid chain-id`);
            break;
        }
      },
      uriR: function uriR(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.uriR = utils.charsToString(chars, phraseIndex, result.phraseLength);
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid resource URI`);
            break;
        }
      },
      resource: function resource(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.resources.push(data.uriR);
            delete data.uriR;
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid resource`);
            break;
        }
      },
      // handle the URI
      scheme: function scheme(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.uriElements.scheme = utils.charsToString(chars, phraseIndex, result.phraseLength);
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid URI scheme`);
            break;
        }
      },
      userinfo: function userinfo(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.uriElements.userinfo = utils.charsToString(chars, phraseIndex, result.phraseLength - 1);
            break;
        }
      },
      host: function host(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            data.iplit = false;
            break;
          case id.MATCH:
            if (data.iplit) {
              data.uriElements.host = utils.charsToString(chars, phraseIndex + 1, result.phraseLength - 2);
            } else {
              data.uriElements.host = utils.charsToString(chars, phraseIndex, result.phraseLength);
            }
            break;
          case id.EMPTY:
            data.uriElements.host = "";
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid URI host`);
            break;
        }
      },
      ipLiteral: function ipLiteral(result, chars, phraseIndex, data) {
        if (result.state === id.MATCH) {
          data.iplit = true;
        }
      },
      port: function port(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.uriElements.port = (0, utils_1.parseIntegerNumber)(utils.charsToString(chars, phraseIndex, result.phraseLength));
            break;
          case id.EMPTY:
            data.uriElements.port = "";
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid URI port`);
            break;
        }
      },
      pathAbempty: function pathAbempty(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.uriElements.path = utils.charsToString(chars, phraseIndex, result.phraseLength);
            break;
          case id.EMPTY:
            data.uriElements.path = "";
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid URI path-abempty`);
            break;
        }
      },
      pathAbsolute: function pathAbsolute(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.uriElements.path = utils.charsToString(chars, phraseIndex, result.phraseLength);
            break;
        }
      },
      pathRootless: function pathRootless(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.uriElements.path = utils.charsToString(chars, phraseIndex, result.phraseLength);
            break;
        }
      },
      pathEmpty: function pathEmpty(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid URI - path-empty must be empty`);
            break;
          case id.EMPTY:
            data.uriElements.path = "";
            break;
        }
      },
      query: function query(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.uriElements.query = utils.charsToString(chars, phraseIndex, result.phraseLength);
            break;
          case id.EMPTY:
            data.uriElements.query = "";
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid URI query`);
            break;
        }
      },
      fragment: function fragment(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.uriElements.fragment = utils.charsToString(chars, phraseIndex, result.phraseLength);
            break;
          case id.EMPTY:
            data.uriElements.fragment = "";
            break;
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid URI fragment`);
            break;
        }
      },
      uri: function URI(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.uri = utils.charsToString(chars, phraseIndex, result.phraseLength);
            break;
          case id.EMPTY:
          case id.NOMATCH:
            data.errors.push(`line ${data.lineno}: invalid URI`);
            break;
        }
      },
      ipv4: function ipv4(result, chars, phraseIndex, data) {
        if (result.state === id.MATCH) {
          data.ipv4 = true;
        }
      },
      h16: function h16(result, chars, phraseIndex, data) {
        if (result.state === id.MATCH) {
          data.h16count += 1;
        }
      },
      nodcolon: function nodcolon(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            data.h16count = 0;
            data.ipv4 = false;
            break;
          case id.MATCH:
            if (data.ipv4) {
              if (data.h16count === 6) {
                result.state = id.MATCH;
              } else {
                result.state = id.NOMATCH;
                result.phraseLength = 0;
              }
            } else {
              if (data.h16count === 8) {
                result.state = id.MATCH;
              } else {
                result.state = id.NOMATCH;
                result.phraseLength = 0;
              }
            }
            break;
        }
      },
      dcolon: function dcolon(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            data.h16count = 0;
            data.ipv4 = false;
            break;
          case id.MATCH:
            if (data.ipv4) {
              if (data.h16count < 6) {
                result.state = id.MATCH;
              } else {
                result.state = id.NOMATCH;
                result.phraseLength = 0;
              }
            } else {
              if (data.h16count < 8) {
                result.state = id.MATCH;
              } else {
                result.state = id.NOMATCH;
                result.phraseLength = 0;
              }
            }
            break;
        }
      },
      decOctet: function decOctet(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.ACTIVE:
            data.octet = 0;
            break;
          case id.MATCH:
            if (data.octet > 255) {
              result.state = id.NOMATCH;
              result.phraseLength = 0;
            } else {
              result.state = id.MATCH;
            }
            break;
        }
      },
      decDigit: function decDigit(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id.MATCH:
            data.octet = 10 * data.octet + chars[phraseIndex] - 48;
            break;
        }
      }
    };
  }
});

// node_modules/@spruceid/siwe-parser/dist/abnf.js
var require_abnf = __commonJS({
  "node_modules/@spruceid/siwe-parser/dist/abnf.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUri = exports.ParsedMessage = void 0;
    var siwe_grammar_1 = require_siwe_grammar();
    var callbacks_1 = require_callbacks();
    var node_exports_1 = __importDefault(require_node_exports());
    var grammarObj = new siwe_grammar_1.grammar();
    var ParsedMessage = class {
      // and display it on an HTML page.
      constructor(msg) {
        const parser = new node_exports_1.default.parser();
        parser.callbacks["sign-in-with-ethereum"] = callbacks_1.cb.signInWithEtherium;
        parser.callbacks["oscheme"] = callbacks_1.cb.oscheme;
        parser.callbacks["domain"] = callbacks_1.cb.domain;
        parser.callbacks["LF"] = callbacks_1.cb.lineno;
        parser.callbacks["ex-title"] = callbacks_1.cb.exTitle;
        parser.callbacks["nb-title"] = callbacks_1.cb.nbTitle;
        parser.callbacks["ri-title"] = callbacks_1.cb.riTitle;
        parser.callbacks["re-title"] = callbacks_1.cb.reTitle;
        parser.callbacks["address"] = callbacks_1.cb.address;
        parser.callbacks["statement"] = callbacks_1.cb.statement;
        parser.callbacks["empty-statement"] = callbacks_1.cb.emptyStatement;
        parser.callbacks["version"] = callbacks_1.cb.version;
        parser.callbacks["chain-id"] = callbacks_1.cb.chainId;
        parser.callbacks["nonce"] = callbacks_1.cb.nonce;
        parser.callbacks["issued-at"] = callbacks_1.cb.issuedAt;
        parser.callbacks["expiration-time"] = callbacks_1.cb.expirationTime;
        parser.callbacks["not-before"] = callbacks_1.cb.notBefore;
        parser.callbacks["request-id"] = callbacks_1.cb.requestId;
        parser.callbacks["uri"] = callbacks_1.cb.uri;
        parser.callbacks["uri-r"] = callbacks_1.cb.uriR;
        parser.callbacks["resource"] = callbacks_1.cb.resource;
        parser.callbacks["scheme"] = callbacks_1.cb.scheme;
        parser.callbacks["userinfo-at"] = callbacks_1.cb.userinfo;
        parser.callbacks["host"] = callbacks_1.cb.host;
        parser.callbacks["IP-literal"] = callbacks_1.cb.ipLiteral;
        parser.callbacks["port"] = callbacks_1.cb.port;
        parser.callbacks["path-abempty"] = callbacks_1.cb.pathAbempty;
        parser.callbacks["path-absolute"] = callbacks_1.cb.pathAbsolute;
        parser.callbacks["path-rootless"] = callbacks_1.cb.pathRootless;
        parser.callbacks["path-empty"] = callbacks_1.cb.pathEmpty;
        parser.callbacks["query"] = callbacks_1.cb.query;
        parser.callbacks["fragment"] = callbacks_1.cb.fragment;
        parser.callbacks["IPv4address"] = callbacks_1.cb.ipv4;
        parser.callbacks["nodcolon"] = callbacks_1.cb.nodcolon;
        parser.callbacks["dcolon"] = callbacks_1.cb.dcolon;
        parser.callbacks["h16"] = callbacks_1.cb.h16;
        parser.callbacks["h16c"] = callbacks_1.cb.h16;
        parser.callbacks["h16n"] = callbacks_1.cb.h16;
        parser.callbacks["h16cn"] = callbacks_1.cb.h16;
        parser.callbacks["dec-octet"] = callbacks_1.cb.decOctet;
        parser.callbacks["dec-digit"] = callbacks_1.cb.decDigit;
        const elements = {
          errors: [],
          lineno: 1,
          scheme: void 0,
          domain: void 0,
          address: void 0,
          statement: void 0,
          uri: void 0,
          version: void 0,
          chainId: void 0,
          nonce: void 0,
          issuedAt: void 0,
          expirationTime: void 0,
          notBefore: void 0,
          requestId: void 0,
          resources: void 0,
          uriElements: {
            scheme: void 0,
            userinfo: void 0,
            host: void 0,
            port: void 0,
            path: void 0,
            query: void 0,
            fragment: void 0
          }
        };
        const result = parser.parse(grammarObj, 0, msg, elements);
        let throwMsg = "";
        for (let i = 0; i < elements.errors.length; i += 1) {
          throwMsg += elements.errors[i] + "\n";
        }
        if (!result.success) {
          throwMsg += `Invalid message: ${JSON.stringify(result)}`;
        }
        if (throwMsg !== "") {
          throw new Error(throwMsg);
        }
        this.scheme = elements.scheme;
        this.domain = elements.domain;
        this.address = elements.address;
        this.statement = elements.statement;
        this.uri = elements.uri;
        this.version = elements.version;
        this.chainId = elements.chainId;
        this.nonce = elements.nonce;
        this.issuedAt = elements.issuedAt;
        this.expirationTime = elements.expirationTime;
        this.notBefore = elements.notBefore;
        this.requestId = elements.requestId;
        this.resources = elements.resources;
        this.uriElements = elements.uriElements;
      }
    };
    exports.ParsedMessage = ParsedMessage;
    var isUri = (uri) => {
      const parser = new node_exports_1.default.parser();
      parser.callbacks["IP-literal"] = callbacks_1.cb.ipLiteral;
      parser.callbacks["IPv4address"] = callbacks_1.cb.ipv4;
      parser.callbacks["nodcolon"] = callbacks_1.cb.nodcolon;
      parser.callbacks["dcolon"] = callbacks_1.cb.dcolon;
      parser.callbacks["h16"] = callbacks_1.cb.h16;
      parser.callbacks["h16c"] = callbacks_1.cb.h16;
      parser.callbacks["h16n"] = callbacks_1.cb.h16;
      parser.callbacks["h16cn"] = callbacks_1.cb.h16;
      parser.callbacks["dec-octet"] = callbacks_1.cb.decOctet;
      parser.callbacks["dec-digit"] = callbacks_1.cb.decDigit;
      const data = { errors: [] };
      const result = parser.parse(grammarObj, "uri-r", uri, data);
      return result.success;
    };
    exports.isUri = isUri;
  }
});

// node_modules/@spruceid/siwe-parser/dist/parsers.js
var require_parsers = __commonJS({
  "node_modules/@spruceid/siwe-parser/dist/parsers.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUri = exports.ParsedMessage = void 0;
    var abnf_1 = require_abnf();
    Object.defineProperty(exports, "ParsedMessage", { enumerable: true, get: function() {
      return abnf_1.ParsedMessage;
    } });
    var abnf_2 = require_abnf();
    Object.defineProperty(exports, "isUri", { enumerable: true, get: function() {
      return abnf_2.isUri;
    } });
    __exportStar(require_utils2(), exports);
  }
});

// node_modules/siwe/dist/ethersCompat.js
var require_ethersCompat = __commonJS({
  "node_modules/siwe/dist/ethersCompat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAddress = exports.hashMessage = exports.verifyMessage = void 0;
    var ethers_1 = (init_lib(), __toCommonJS(lib_exports));
    var ethersVerifyMessage = null;
    var ethersHashMessage = null;
    var ethersGetAddress = null;
    try {
      ethersVerifyMessage = ethers_1.ethers.utils.verifyMessage;
      ethersHashMessage = ethers_1.ethers.utils.hashMessage;
      ethersGetAddress = ethers_1.ethers.utils.getAddress;
    } catch (_a) {
      ethersVerifyMessage = ethers_1.ethers.verifyMessage;
      ethersHashMessage = ethers_1.ethers.hashMessage;
      ethersGetAddress = ethers_1.ethers.getAddress;
    }
    exports.verifyMessage = ethersVerifyMessage;
    exports.hashMessage = ethersHashMessage;
    exports.getAddress = ethersGetAddress;
  }
});

// node_modules/siwe/dist/types.js
var require_types = __commonJS({
  "node_modules/siwe/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SiweErrorType = exports.SiweError = exports.VerifyOptsKeys = exports.VerifyParamsKeys = void 0;
    exports.VerifyParamsKeys = [
      "signature",
      "scheme",
      "domain",
      "nonce",
      "time"
    ];
    exports.VerifyOptsKeys = [
      "provider",
      "suppressExceptions",
      "verificationFallback"
    ];
    var SiweError = class {
      constructor(type, expected, received) {
        this.type = type;
        this.expected = expected;
        this.received = received;
      }
    };
    exports.SiweError = SiweError;
    var SiweErrorType;
    (function(SiweErrorType2) {
      SiweErrorType2["EXPIRED_MESSAGE"] = "Expired message.";
      SiweErrorType2["INVALID_DOMAIN"] = "Invalid domain.";
      SiweErrorType2["SCHEME_MISMATCH"] = "Scheme does not match provided scheme for verification.";
      SiweErrorType2["DOMAIN_MISMATCH"] = "Domain does not match provided domain for verification.";
      SiweErrorType2["NONCE_MISMATCH"] = "Nonce does not match provided nonce for verification.";
      SiweErrorType2["INVALID_ADDRESS"] = "Invalid address.";
      SiweErrorType2["INVALID_URI"] = "URI does not conform to RFC 3986.";
      SiweErrorType2["INVALID_NONCE"] = "Nonce size smaller then 8 characters or is not alphanumeric.";
      SiweErrorType2["NOT_YET_VALID_MESSAGE"] = "Message is not valid yet.";
      SiweErrorType2["INVALID_SIGNATURE"] = "Signature does not match address of the message.";
      SiweErrorType2["INVALID_TIME_FORMAT"] = "Invalid time format.";
      SiweErrorType2["INVALID_MESSAGE_VERSION"] = "Invalid message version.";
      SiweErrorType2["UNABLE_TO_PARSE"] = "Unable to parse the message.";
    })(SiweErrorType = exports.SiweErrorType || (exports.SiweErrorType = {}));
  }
});

// node_modules/@stablelib/random/lib/source/browser.js
var require_browser = __commonJS({
  "node_modules/@stablelib/random/lib/source/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowserRandomSource = void 0;
    var QUOTA = 65536;
    var BrowserRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
          this._crypto = browserCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
      randomBytes(length) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length);
        for (let i = 0; i < out.length; i += QUOTA) {
          this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
        }
        return out;
      }
    };
    exports.BrowserRandomSource = BrowserRandomSource;
  }
});

// node_modules/@stablelib/wipe/lib/wipe.js
var require_wipe = __commonJS({
  "node_modules/@stablelib/wipe/lib/wipe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function wipe(array) {
      for (var i = 0; i < array.length; i++) {
        array[i] = 0;
      }
      return array;
    }
    exports.wipe = wipe;
  }
});

// browser-external:crypto
var require_crypto2 = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@stablelib/random/lib/source/node.js
var require_node = __commonJS({
  "node_modules/@stablelib/random/lib/source/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeRandomSource = void 0;
    var wipe_1 = require_wipe();
    var NodeRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof __require !== "undefined") {
          const nodeCrypto = require_crypto2();
          if (nodeCrypto && nodeCrypto.randomBytes) {
            this._crypto = nodeCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
      }
      randomBytes(length) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Node.js random byte generator is not available.");
        }
        let buffer = this._crypto.randomBytes(length);
        if (buffer.length !== length) {
          throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        const out = new Uint8Array(length);
        for (let i = 0; i < out.length; i++) {
          out[i] = buffer[i];
        }
        (0, wipe_1.wipe)(buffer);
        return out;
      }
    };
    exports.NodeRandomSource = NodeRandomSource;
  }
});

// node_modules/@stablelib/random/lib/source/system.js
var require_system = __commonJS({
  "node_modules/@stablelib/random/lib/source/system.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SystemRandomSource = void 0;
    var browser_1 = require_browser();
    var node_1 = require_node();
    var SystemRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.name = "";
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Browser";
          return;
        }
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Node";
          return;
        }
      }
      randomBytes(length) {
        if (!this.isAvailable) {
          throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length);
      }
    };
    exports.SystemRandomSource = SystemRandomSource;
  }
});

// node_modules/@stablelib/int/lib/int.js
var require_int = __commonJS({
  "node_modules/@stablelib/int/lib/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function imulShim(a, b) {
      var ah = a >>> 16 & 65535, al = a & 65535;
      var bh = b >>> 16 & 65535, bl = b & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    exports.mul = Math.imul || imulShim;
    function add(a, b) {
      return a + b | 0;
    }
    exports.add = add;
    function sub(a, b) {
      return a - b | 0;
    }
    exports.sub = sub;
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    exports.rotl = rotl;
    function rotr(x, n) {
      return x << 32 - n | x >>> n;
    }
    exports.rotr = rotr;
    function isIntegerShim(n) {
      return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
    }
    exports.isInteger = Number.isInteger || isIntegerShim;
    exports.MAX_SAFE_INTEGER = 9007199254740991;
    exports.isSafeInteger = function(n) {
      return exports.isInteger(n) && (n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER);
    };
  }
});

// node_modules/@stablelib/binary/lib/binary.js
var require_binary = __commonJS({
  "node_modules/@stablelib/binary/lib/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var int_1 = require_int();
    function readInt16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
    }
    exports.readInt16BE = readInt16BE;
    function readUint16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
    }
    exports.readUint16BE = readUint16BE;
    function readInt16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
    }
    exports.readInt16LE = readInt16LE;
    function readUint16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports.readUint16LE = readUint16LE;
    function writeUint16BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 8;
      out[offset + 1] = value >>> 0;
      return out;
    }
    exports.writeUint16BE = writeUint16BE;
    exports.writeInt16BE = writeUint16BE;
    function writeUint16LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      return out;
    }
    exports.writeUint16LE = writeUint16LE;
    exports.writeInt16LE = writeUint16LE;
    function readInt32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
    }
    exports.readInt32BE = readInt32BE;
    function readUint32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
    }
    exports.readUint32BE = readUint32BE;
    function readInt32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
    }
    exports.readInt32LE = readInt32LE;
    function readUint32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports.readUint32LE = readUint32LE;
    function writeUint32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 24;
      out[offset + 1] = value >>> 16;
      out[offset + 2] = value >>> 8;
      out[offset + 3] = value >>> 0;
      return out;
    }
    exports.writeUint32BE = writeUint32BE;
    exports.writeInt32BE = writeUint32BE;
    function writeUint32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      out[offset + 2] = value >>> 16;
      out[offset + 3] = value >>> 24;
      return out;
    }
    exports.writeUint32LE = writeUint32LE;
    exports.writeInt32LE = writeUint32LE;
    function readInt64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readInt32BE(array, offset);
      var lo = readInt32BE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports.readInt64BE = readInt64BE;
    function readUint64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readUint32BE(array, offset);
      var lo = readUint32BE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports.readUint64BE = readUint64BE;
    function readInt64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readInt32LE(array, offset);
      var hi = readInt32LE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports.readInt64LE = readInt64LE;
    function readUint64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readUint32LE(array, offset);
      var hi = readUint32LE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports.readUint64LE = readUint64LE;
    function writeUint64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32BE(value / 4294967296 >>> 0, out, offset);
      writeUint32BE(value >>> 0, out, offset + 4);
      return out;
    }
    exports.writeUint64BE = writeUint64BE;
    exports.writeInt64BE = writeUint64BE;
    function writeUint64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32LE(value >>> 0, out, offset);
      writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
      return out;
    }
    exports.writeUint64LE = writeUint64LE;
    exports.writeInt64LE = writeUint64LE;
    function readUintBE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        result += array[i] * mul;
        mul *= 256;
      }
      return result;
    }
    exports.readUintBE = readUintBE;
    function readUintLE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i = offset; i < offset + bitLength / 8; i++) {
        result += array[i] * mul;
        mul *= 256;
      }
      return result;
    }
    exports.readUintLE = readUintLE;
    function writeUintBE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
      }
      var div = 1;
      for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        out[i] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports.writeUintBE = writeUintBE;
    function writeUintLE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
      }
      var div = 1;
      for (var i = offset; i < offset + bitLength / 8; i++) {
        out[i] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports.writeUintLE = writeUintLE;
    function readFloat32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset);
    }
    exports.readFloat32BE = readFloat32BE;
    function readFloat32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset, true);
    }
    exports.readFloat32LE = readFloat32LE;
    function readFloat64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset);
    }
    exports.readFloat64BE = readFloat64BE;
    function readFloat64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset, true);
    }
    exports.readFloat64LE = readFloat64LE;
    function writeFloat32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value);
      return out;
    }
    exports.writeFloat32BE = writeFloat32BE;
    function writeFloat32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value, true);
      return out;
    }
    exports.writeFloat32LE = writeFloat32LE;
    function writeFloat64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value);
      return out;
    }
    exports.writeFloat64BE = writeFloat64BE;
    function writeFloat64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value, true);
      return out;
    }
    exports.writeFloat64LE = writeFloat64LE;
  }
});

// node_modules/@stablelib/random/lib/random.js
var require_random = __commonJS({
  "node_modules/@stablelib/random/lib/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
    var system_1 = require_system();
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes(length, prng = exports.defaultRandomSource) {
      return prng.randomBytes(length);
    }
    exports.randomBytes = randomBytes;
    function randomUint32(prng = exports.defaultRandomSource) {
      const buf = randomBytes(4, prng);
      const result = (0, binary_1.readUint32LE)(buf);
      (0, wipe_1.wipe)(buf);
      return result;
    }
    exports.randomUint32 = randomUint32;
    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString(length, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      let out = "";
      const charsLen = charset.length;
      const maxByte = 256 - 256 % charsLen;
      while (length > 0) {
        const buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);
        for (let i = 0; i < buf.length && length > 0; i++) {
          const randomByte = buf[i];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length--;
          }
        }
        (0, wipe_1.wipe)(buf);
      }
      return out;
    }
    exports.randomString = randomString;
    function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      const length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
      return randomString(length, charset, prng);
    }
    exports.randomStringForEntropy = randomStringForEntropy;
  }
});

// node_modules/siwe/dist/utils.js
var require_utils3 = __commonJS({
  "node_modules/siwe/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkInvalidKeys = exports.isValidISO8601Date = exports.generateNonce = exports.checkContractWalletSignature = void 0;
    var random_1 = require_random();
    var ethers_1 = (init_lib(), __toCommonJS(lib_exports));
    var ethersCompat_1 = require_ethersCompat();
    var EIP1271_ABI = [
      "function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)"
    ];
    var EIP1271_MAGICVALUE = "0x1626ba7e";
    var ISO8601 = /^(?<date>[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(.[0-9]+)?(([Zz])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
    var checkContractWalletSignature = async (message, signature, provider) => {
      if (!provider) {
        return false;
      }
      const walletContract = new ethers_1.Contract(message.address, EIP1271_ABI, provider);
      const hashedMessage = (0, ethersCompat_1.hashMessage)(message.prepareMessage());
      const res = await walletContract.isValidSignature(hashedMessage, signature);
      return res === EIP1271_MAGICVALUE;
    };
    exports.checkContractWalletSignature = checkContractWalletSignature;
    var generateNonce = () => {
      const nonce = (0, random_1.randomStringForEntropy)(96);
      if (!nonce || nonce.length < 8) {
        throw new Error("Error during nonce creation.");
      }
      return nonce;
    };
    exports.generateNonce = generateNonce;
    var isValidISO8601Date = (inputDate) => {
      const inputMatch = ISO8601.exec(inputDate);
      if (!inputMatch) {
        return false;
      }
      const inputDateParsed = new Date(inputMatch.groups.date).toISOString();
      const parsedInputMatch = ISO8601.exec(inputDateParsed);
      return inputMatch.groups.date === parsedInputMatch.groups.date;
    };
    exports.isValidISO8601Date = isValidISO8601Date;
    var checkInvalidKeys = (obj, keys) => {
      const invalidKeys = [];
      Object.keys(obj).forEach((key) => {
        if (!keys.includes(key)) {
          invalidKeys.push(key);
        }
      });
      return invalidKeys;
    };
    exports.checkInvalidKeys = checkInvalidKeys;
  }
});

// node_modules/siwe/dist/client.js
var require_client = __commonJS({
  "node_modules/siwe/dist/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SiweMessage = void 0;
    var siwe_parser_1 = require_parsers();
    var ethersCompat_1 = require_ethersCompat();
    var types_1 = require_types();
    var utils_1 = require_utils3();
    var SiweMessage = class {
      /**
       * Creates a parsed Sign-In with Ethereum Message (EIP-4361) object from a
       * string or an object. If a string is used an ABNF parser is called to
       * validate the parameter, otherwise the fields are attributed.
       * @param param {string | SiweMessage} Sign message as a string or an object.
       */
      constructor(param) {
        if (typeof param === "string") {
          const parsedMessage = new siwe_parser_1.ParsedMessage(param);
          this.scheme = parsedMessage.scheme;
          this.domain = parsedMessage.domain;
          this.address = parsedMessage.address;
          this.statement = parsedMessage.statement;
          this.uri = parsedMessage.uri;
          this.version = parsedMessage.version;
          this.nonce = parsedMessage.nonce;
          this.issuedAt = parsedMessage.issuedAt;
          this.expirationTime = parsedMessage.expirationTime;
          this.notBefore = parsedMessage.notBefore;
          this.requestId = parsedMessage.requestId;
          this.chainId = parsedMessage.chainId;
          this.resources = parsedMessage.resources;
        } else {
          this.scheme = param === null || param === void 0 ? void 0 : param.scheme;
          this.domain = param.domain;
          this.address = param.address;
          this.statement = param === null || param === void 0 ? void 0 : param.statement;
          this.uri = param.uri;
          this.version = param.version;
          this.chainId = param.chainId;
          this.nonce = param.nonce;
          this.issuedAt = param === null || param === void 0 ? void 0 : param.issuedAt;
          this.expirationTime = param === null || param === void 0 ? void 0 : param.expirationTime;
          this.notBefore = param === null || param === void 0 ? void 0 : param.notBefore;
          this.requestId = param === null || param === void 0 ? void 0 : param.requestId;
          this.resources = param === null || param === void 0 ? void 0 : param.resources;
          if (typeof this.chainId === "string") {
            this.chainId = (0, siwe_parser_1.parseIntegerNumber)(this.chainId);
          }
          this.nonce = this.nonce || (0, utils_1.generateNonce)();
          new siwe_parser_1.ParsedMessage(this.prepareMessage());
        }
      }
      /**
       * This function can be used to retrieve an EIP-4361 formatted message for
       * signature, although you can call it directly it's advised to use
       * [prepareMessage()] instead which will resolve to the correct method based
       * on the [type] attribute of this object, in case of other formats being
       * implemented.
       * @returns {string} EIP-4361 formatted message, ready for EIP-191 signing.
       */
      toMessage() {
        const headerPrefix = this.scheme ? `${this.scheme}://${this.domain}` : this.domain;
        const header = `${headerPrefix} wants you to sign in with your Ethereum account:`;
        const uriField = `URI: ${this.uri}`;
        let prefix = [header, this.address].join("\n");
        const versionField = `Version: ${this.version}`;
        if (!this.nonce) {
          this.nonce = (0, utils_1.generateNonce)();
        }
        const chainField = `Chain ID: ` + this.chainId || "1";
        const nonceField = `Nonce: ${this.nonce}`;
        const suffixArray = [uriField, versionField, chainField, nonceField];
        this.issuedAt = this.issuedAt || (/* @__PURE__ */ new Date()).toISOString();
        suffixArray.push(`Issued At: ${this.issuedAt}`);
        if (this.expirationTime) {
          const expiryField = `Expiration Time: ${this.expirationTime}`;
          suffixArray.push(expiryField);
        }
        if (this.notBefore) {
          suffixArray.push(`Not Before: ${this.notBefore}`);
        }
        if (this.requestId) {
          suffixArray.push(`Request ID: ${this.requestId}`);
        }
        if (this.resources) {
          suffixArray.push([`Resources:`, ...this.resources.map((x) => `- ${x}`)].join("\n"));
        }
        const suffix = suffixArray.join("\n");
        prefix = [prefix, this.statement].join("\n\n");
        if (this.statement !== void 0) {
          prefix += "\n";
        }
        return [prefix, suffix].join("\n");
      }
      /**
       * This method parses all the fields in the object and creates a messaging for signing
       * message according with the type defined.
       * @returns {string} Returns a message ready to be signed according with the
       * type defined in the object.
       */
      prepareMessage() {
        let message;
        switch (this.version) {
          case "1": {
            message = this.toMessage();
            break;
          }
          default: {
            message = this.toMessage();
            break;
          }
        }
        return message;
      }
      /**
       * Verifies the integrity of the object by matching its signature.
       * @param params Parameters to verify the integrity of the message, signature is required.
       * @returns {Promise<SiweMessage>} This object if valid.
       */
      async verify(params, opts = { suppressExceptions: false }) {
        return new Promise((resolve, reject) => {
          var _a, _b, _c;
          const fail = (result) => {
            if (opts.suppressExceptions) {
              return resolve(result);
            } else {
              return reject(result);
            }
          };
          const invalidParams = (0, utils_1.checkInvalidKeys)(params, types_1.VerifyParamsKeys);
          if (invalidParams.length > 0) {
            fail({
              success: false,
              data: this,
              error: new Error(`${invalidParams.join(", ")} is/are not valid key(s) for VerifyParams.`)
            });
          }
          const invalidOpts = (0, utils_1.checkInvalidKeys)(opts, types_1.VerifyOptsKeys);
          if (invalidOpts.length > 0) {
            fail({
              success: false,
              data: this,
              error: new Error(`${invalidOpts.join(", ")} is/are not valid key(s) for VerifyOpts.`)
            });
          }
          const { signature, scheme, domain, nonce, time } = params;
          if (scheme && scheme !== this.scheme) {
            fail({
              success: false,
              data: this,
              error: new types_1.SiweError(types_1.SiweErrorType.SCHEME_MISMATCH, scheme, this.scheme)
            });
          }
          if (domain && domain !== this.domain) {
            fail({
              success: false,
              data: this,
              error: new types_1.SiweError(types_1.SiweErrorType.DOMAIN_MISMATCH, domain, this.domain)
            });
          }
          if (nonce && nonce !== this.nonce) {
            fail({
              success: false,
              data: this,
              error: new types_1.SiweError(types_1.SiweErrorType.NONCE_MISMATCH, nonce, this.nonce)
            });
          }
          const checkTime = new Date(time || /* @__PURE__ */ new Date());
          if (this.expirationTime) {
            const expirationDate = new Date(this.expirationTime);
            if (checkTime.getTime() >= expirationDate.getTime()) {
              fail({
                success: false,
                data: this,
                error: new types_1.SiweError(types_1.SiweErrorType.EXPIRED_MESSAGE, `${checkTime.toISOString()} < ${expirationDate.toISOString()}`, `${checkTime.toISOString()} >= ${expirationDate.toISOString()}`)
              });
            }
          }
          if (this.notBefore) {
            const notBefore = new Date(this.notBefore);
            if (checkTime.getTime() < notBefore.getTime()) {
              fail({
                success: false,
                data: this,
                error: new types_1.SiweError(types_1.SiweErrorType.NOT_YET_VALID_MESSAGE, `${checkTime.toISOString()} >= ${notBefore.toISOString()}`, `${checkTime.toISOString()} < ${notBefore.toISOString()}`)
              });
            }
          }
          let EIP4361Message;
          try {
            EIP4361Message = this.prepareMessage();
          } catch (e) {
            fail({
              success: false,
              data: this,
              error: e
            });
          }
          let addr;
          try {
            addr = (0, ethersCompat_1.verifyMessage)(EIP4361Message, signature);
          } catch (e) {
            console.error(e);
          }
          if (addr === this.address) {
            return resolve({
              success: true,
              data: this
            });
          } else {
            const EIP1271Promise = (0, utils_1.checkContractWalletSignature)(this, signature, opts.provider).then((isValid) => {
              if (!isValid) {
                return {
                  success: false,
                  data: this,
                  error: new types_1.SiweError(types_1.SiweErrorType.INVALID_SIGNATURE, addr, `Resolved address to be ${this.address}`)
                };
              }
              return {
                success: true,
                data: this
              };
            }).catch((error) => {
              return {
                success: false,
                data: this,
                error
              };
            });
            Promise.all([
              EIP1271Promise,
              (_c = (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.verificationFallback) === null || _a === void 0 ? void 0 : _a.call(opts, params, opts, this, EIP1271Promise)) === null || _b === void 0 ? void 0 : _b.then((res) => res)) === null || _c === void 0 ? void 0 : _c.catch((res) => res)
            ]).then(([EIP1271Response, fallbackResponse]) => {
              if (fallbackResponse) {
                if (fallbackResponse.success) {
                  return resolve(fallbackResponse);
                } else {
                  fail(fallbackResponse);
                }
              } else {
                if (EIP1271Response.success) {
                  return resolve(EIP1271Response);
                } else {
                  fail(EIP1271Response);
                }
              }
            });
          }
        });
      }
    };
    exports.SiweMessage = SiweMessage;
  }
});

// node_modules/siwe/dist/siwe.js
var require_siwe = __commonJS({
  "node_modules/siwe/dist/siwe.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_client(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_utils3(), exports);
  }
});
export default require_siwe();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=siwe.js.map
